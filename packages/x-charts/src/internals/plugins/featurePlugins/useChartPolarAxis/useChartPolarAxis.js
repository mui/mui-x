"use strict";
'use client';
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useChartPolarAxis = void 0;
var React = require("react");
var warning_1 = require("@mui/x-internals/warning");
var useSelector_1 = require("../../../store/useSelector");
var useChartDimensions_selectors_1 = require("../../corePlugins/useChartDimensions/useChartDimensions.selectors");
var defaultizeAxis_1 = require("./defaultizeAxis");
var useChartInteraction_1 = require("../useChartInteraction");
var useChartPolarAxis_selectors_1 = require("./useChartPolarAxis.selectors");
var getSVGPoint_1 = require("../../../getSVGPoint");
var coordinateTransformation_1 = require("./coordinateTransformation");
var getAxisIndex_1 = require("./getAxisIndex");
var useChartSeries_1 = require("../../corePlugins/useChartSeries");
var useChartPolarAxis = function (_a) {
    var params = _a.params, store = _a.store, seriesConfig = _a.seriesConfig, svgRef = _a.svgRef, instance = _a.instance;
    var rotationAxis = params.rotationAxis, radiusAxis = params.radiusAxis, dataset = params.dataset;
    if (process.env.NODE_ENV !== 'production') {
        var ids_1 = __spreadArray(__spreadArray([], (rotationAxis !== null && rotationAxis !== void 0 ? rotationAxis : []), true), (radiusAxis !== null && radiusAxis !== void 0 ? radiusAxis : []), true).filter(function (axis) { return axis.id; })
            .map(function (axis) { return axis.id; });
        var duplicates = new Set(ids_1.filter(function (id, index) { return ids_1.indexOf(id) !== index; }));
        if (duplicates.size > 0) {
            (0, warning_1.warnOnce)([
                "MUI X Charts: The following axis ids are duplicated: ".concat(Array.from(duplicates).join(', '), "."),
                "Please make sure that each axis has a unique id.",
            ].join('\n'), 'error');
        }
    }
    var drawingArea = (0, useSelector_1.useSelector)(store, useChartDimensions_selectors_1.selectorChartDrawingArea);
    var processedSeries = (0, useSelector_1.useSelector)(store, useChartSeries_1.selectorChartSeriesProcessed);
    var center = (0, useSelector_1.useSelector)(store, useChartPolarAxis_selectors_1.selectorChartPolarCenter);
    var isInteractionEnabled = (0, useSelector_1.useSelector)(store, useChartInteraction_1.selectorChartsInteractionIsInitialized);
    var _b = (0, useSelector_1.useSelector)(store, useChartPolarAxis_selectors_1.selectorChartRotationAxis), rotationAxisWithScale = _b.axis, rotationAxisIds = _b.axisIds;
    var _c = (0, useSelector_1.useSelector)(store, useChartPolarAxis_selectors_1.selectorChartRadiusAxis), radiusAxisWithScale = _c.axis, radiusAxisIds = _c.axisIds;
    // The effect do not track any value defined synchronously during the 1st render by hooks called after `useChartPolarAxis`
    // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one
    var isFirstRender = React.useRef(true);
    React.useEffect(function () {
        if (isFirstRender.current) {
            isFirstRender.current = false;
            return;
        }
        store.update(function (prev) { return (__assign(__assign({}, prev), { polarAxis: __assign(__assign({}, prev.polarAxis), { rotation: (0, defaultizeAxis_1.defaultizeAxis)(rotationAxis, dataset, 'rotation'), radius: (0, defaultizeAxis_1.defaultizeAxis)(radiusAxis, dataset, 'radius') }) })); });
    }, [seriesConfig, drawingArea, rotationAxis, radiusAxis, dataset, store]);
    var svg2rotation = React.useMemo(function () { return (0, coordinateTransformation_1.generateSvg2rotation)({ cx: center.cx, cy: center.cy }); }, [center.cx, center.cy]);
    var svg2polar = React.useMemo(function () { return (0, coordinateTransformation_1.generateSvg2polar)({ cx: center.cx, cy: center.cy }); }, [center.cx, center.cy]);
    var polar2svg = React.useMemo(function () { return (0, coordinateTransformation_1.generatePolar2svg)({ cx: center.cx, cy: center.cy }); }, [center.cx, center.cy]);
    var usedRotationAxisId = rotationAxisIds[0];
    var usedRadiusAxisId = radiusAxisIds[0];
    // Use a ref to avoid rerendering on every mousemove event.
    var mousePosition = React.useRef({
        isInChart: false,
    });
    React.useEffect(function () {
        var element = svgRef.current;
        if (!isInteractionEnabled || element === null || params.disableAxisListener) {
            return function () { };
        }
        // Clean the interaction when the mouse leaves the chart.
        var moveEndHandler = instance.addInteractionListener('moveEnd', function (event) {
            if (!event.detail.activeGestures.pan) {
                mousePosition.current.isInChart = false;
                instance.cleanInteraction();
            }
        });
        var panEndHandler = instance.addInteractionListener('panEnd', function (event) {
            if (!event.detail.activeGestures.move) {
                mousePosition.current.isInChart = false;
                instance.cleanInteraction();
            }
        });
        var pressEndHandler = instance.addInteractionListener('quickPressEnd', function (event) {
            if (!event.detail.activeGestures.move && !event.detail.activeGestures.pan) {
                mousePosition.current.isInChart = false;
                instance.cleanInteraction();
            }
        });
        var gestureHandler = function (event) {
            var _a;
            var srcEvent = event.detail.srcEvent;
            // On touch, we want to allow user to interact with the entire svg area in
            // order to better display the tooltip.
            if (event.detail.srcEvent.pointerType === 'touch') {
                var svgRect = element.getBoundingClientRect();
                if (srcEvent.clientX < svgRect.left ||
                    srcEvent.clientX > svgRect.right ||
                    srcEvent.clientY < svgRect.top ||
                    srcEvent.clientY > svgRect.bottom) {
                    mousePosition.current.isInChart = false;
                    instance.cleanInteraction();
                    return;
                }
                var svgPoint_1 = (0, getSVGPoint_1.getSVGPoint)(element, srcEvent);
                mousePosition.current.isInChart = true;
                instance.setPointerCoordinate(svgPoint_1);
                return;
            }
            // On mouse, we want to restrict the interaction to the drawing area and radar circle.
            var svgPoint = (0, getSVGPoint_1.getSVGPoint)(element, srcEvent);
            // Test if it's in the drawing area
            if (!instance.isPointInside(svgPoint.x, svgPoint.y, event.detail.target)) {
                if (mousePosition.current.isInChart) {
                    instance === null || instance === void 0 ? void 0 : instance.cleanInteraction();
                    mousePosition.current.isInChart = false;
                }
                return;
            }
            // Test if it's in the radar circle
            var radiusSquare = Math.pow((center.cx - svgPoint.x), 2) + Math.pow((center.cy - svgPoint.y), 2);
            var maxRadius = radiusAxisWithScale[usedRadiusAxisId].scale.range()[1];
            if (radiusSquare > Math.pow(maxRadius, 2)) {
                if (mousePosition.current.isInChart) {
                    instance === null || instance === void 0 ? void 0 : instance.cleanInteraction();
                    mousePosition.current.isInChart = false;
                }
                return;
            }
            mousePosition.current.isInChart = true;
            (_a = instance.setPointerCoordinate) === null || _a === void 0 ? void 0 : _a.call(instance, svgPoint);
        };
        var moveHandler = instance.addInteractionListener('move', gestureHandler);
        var panHandler = instance.addInteractionListener('pan', gestureHandler);
        var pressHandler = instance.addInteractionListener('quickPress', gestureHandler);
        return function () {
            moveHandler.cleanup();
            moveEndHandler.cleanup();
            panHandler.cleanup();
            panEndHandler.cleanup();
            pressHandler.cleanup();
            pressEndHandler.cleanup();
        };
    }, [
        svgRef,
        store,
        center,
        radiusAxisWithScale,
        usedRadiusAxisId,
        rotationAxisWithScale,
        usedRotationAxisId,
        instance,
        params.disableAxisListener,
        isInteractionEnabled,
        svg2rotation,
    ]);
    React.useEffect(function () {
        var element = svgRef.current;
        var onAxisClick = params.onAxisClick;
        if (element === null || !onAxisClick) {
            return function () { };
        }
        var axisClickHandler = instance.addInteractionListener('tap', function (event) {
            var dataIndex = null;
            var isRotationAxis = false;
            var svgPoint = (0, getSVGPoint_1.getSVGPoint)(element, event.detail.srcEvent);
            var rotation = (0, coordinateTransformation_1.generateSvg2rotation)(center)(svgPoint.x, svgPoint.y);
            var rotationIndex = (0, getAxisIndex_1.getAxisIndex)(rotationAxisWithScale[usedRotationAxisId], rotation);
            isRotationAxis = rotationIndex !== -1;
            dataIndex = isRotationAxis ? rotationIndex : null; // radius index is not yet implemented.
            var USED_AXIS_ID = isRotationAxis ? usedRotationAxisId : usedRadiusAxisId;
            if (dataIndex == null || dataIndex === -1) {
                return;
            }
            // The .data exist because otherwise the dataIndex would be null or -1.
            var axisValue = (isRotationAxis ? rotationAxisWithScale : radiusAxisWithScale)[USED_AXIS_ID]
                .data[dataIndex];
            var seriesValues = {};
            Object.keys(processedSeries)
                .filter(function (seriesType) { return seriesType === 'radar'; })
                .forEach(function (seriesType) {
                var _a;
                (_a = processedSeries[seriesType]) === null || _a === void 0 ? void 0 : _a.seriesOrder.forEach(function (seriesId) {
                    var seriesItem = processedSeries[seriesType].series[seriesId];
                    seriesValues[seriesId] = seriesItem.data[dataIndex];
                });
            });
            onAxisClick(event.detail.srcEvent, { dataIndex: dataIndex, axisValue: axisValue, seriesValues: seriesValues });
        });
        return function () {
            axisClickHandler.cleanup();
        };
    }, [
        center,
        instance,
        params.onAxisClick,
        processedSeries,
        radiusAxisWithScale,
        rotationAxisWithScale,
        svgRef,
        usedRadiusAxisId,
        usedRotationAxisId,
    ]);
    return {
        instance: {
            svg2polar: svg2polar,
            svg2rotation: svg2rotation,
            polar2svg: polar2svg,
        },
    };
};
exports.useChartPolarAxis = useChartPolarAxis;
exports.useChartPolarAxis.params = {
    rotationAxis: true,
    radiusAxis: true,
    dataset: true,
    disableAxisListener: true,
    onAxisClick: true,
};
exports.useChartPolarAxis.getInitialState = function (params) { return ({
    polarAxis: {
        rotation: (0, defaultizeAxis_1.defaultizeAxis)(params.rotationAxis, params.dataset, 'rotation'),
        radius: (0, defaultizeAxis_1.defaultizeAxis)(params.radiusAxis, params.dataset, 'radius'),
    },
}); };
