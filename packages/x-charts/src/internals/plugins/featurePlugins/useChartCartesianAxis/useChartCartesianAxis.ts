'use client';
import * as React from 'react';
import useEnhancedEffect from '@mui/utils/useEnhancedEffect';
import { useStoreEffect } from '@mui/x-internals/store';
import { useAssertModelConsistency } from '@mui/x-internals/useAssertModelConsistency';
import { warnOnce } from '@mui/x-internals/warning';
import { type PointerGestureEventData } from '@mui/x-internal-gestures/core';
import { type ChartPlugin } from '../../models';
import { type UseChartCartesianAxisSignature } from './useChartCartesianAxis.types';
import { rainbowSurgePalette } from '../../../../colorPalettes';
import { selectorChartDrawingArea } from '../../corePlugins/useChartDimensions/useChartDimensions.selectors';
import { selectorChartSeriesProcessed } from '../../corePlugins/useChartSeries/useChartSeries.selectors';
import { defaultizeXAxis, defaultizeYAxis } from './defaultizeAxis';
import { selectorChartXAxis, selectorChartYAxis } from './useChartCartesianAxisRendering.selectors';
import { getAxisIndex } from './getAxisValue';
import { getChartPoint } from '../../../getChartPoint';
import { selectorChartsInteractionIsInitialized } from '../useChartInteraction';
import { selectorChartAxisInteraction } from './useChartCartesianInteraction.selectors';
import { checkHasInteractionPlugin } from '../useChartInteraction/checkHasInteractionPlugin';
import { type ChartsAxisData, type SeriesId } from '../../../../models';

const AXIS_CLICK_SERIES_TYPES = new Set(['bar', 'rangeBar', 'line'] as const);
type AxisClickSeriesType = typeof AXIS_CLICK_SERIES_TYPES extends Set<infer U> ? U : never;

export const useChartCartesianAxis: ChartPlugin<UseChartCartesianAxisSignature<any>> = ({
  params,
  store,
  instance,
}) => {
  const { svgRef } = instance;
  const { xAxis, yAxis, dataset, onHighlightedAxisChange, onTooltipAxisChange, axesGap } = params;

  if (process.env.NODE_ENV !== 'production') {
    const ids = [...(xAxis ?? []), ...(yAxis ?? [])]
      .filter((axis) => axis.id)
      .map((axis) => axis.id);
    const duplicates = new Set(ids.filter((id, index) => ids.indexOf(id) !== index));
    if (duplicates.size > 0) {
      warnOnce(
        [
          `MUI X Charts: The following axis ids are duplicated: ${Array.from(duplicates).join(', ')}.`,
          `Please make sure that each axis has a unique id.`,
        ].join('\n'),
        'error',
      );
    }
  }

  const drawingArea = store.use(selectorChartDrawingArea);
  const processedSeries = store.use(selectorChartSeriesProcessed);

  const isInteractionEnabled = store.use(selectorChartsInteractionIsInitialized);
  const { axis: xAxisWithScale, axisIds: xAxisIds } = store.use(selectorChartXAxis);
  const { axis: yAxisWithScale, axisIds: yAxisIds } = store.use(selectorChartYAxis);

  useAssertModelConsistency({
    warningPrefix: 'MUI X Charts',
    componentName: 'Chart',
    propName: 'highlightedAxis',
    controlled: params.highlightedAxis,
    defaultValue: undefined,
  });

  useAssertModelConsistency({
    warningPrefix: 'MUI X Charts',
    componentName: 'Chart',
    propName: 'tooltipAxis',
    controlled: params.tooltipAxis,
    defaultValue: undefined,
  });

  useEnhancedEffect(() => {
    if (params.highlightedAxis !== undefined) {
      store.set('controlledCartesianAxisHighlight', params.highlightedAxis);
    }
  }, [store, params.highlightedAxis]);

  useEnhancedEffect(() => {
    if (params.tooltipAxis !== undefined) {
      store.set('controlledCartesianAxisTooltip', params.tooltipAxis);
    }
  }, [store, params.tooltipAxis]);

  // The effect do not track any value defined synchronously during the 1st render by hooks called after `useChartCartesianAxis`
  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one
  const isFirstRender = React.useRef(true);
  React.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }

    store.set('cartesianAxis', {
      axesGap,
      x: defaultizeXAxis(xAxis, dataset, axesGap),
      y: defaultizeYAxis(yAxis, dataset, axesGap),
    });
  }, [drawingArea, xAxis, yAxis, dataset, axesGap, store]);

  const usedXAxis = xAxisIds[0];
  const usedYAxis = yAxisIds[0];

  useStoreEffect(
    store,
    selectorChartAxisInteraction,
    (prevAxisInteraction, nextAxisInteraction) => {
      if (!onHighlightedAxisChange && !onTooltipAxisChange) {
        return;
      }
      if (Object.is(prevAxisInteraction, nextAxisInteraction)) {
        return;
      }

      if (prevAxisInteraction.length !== nextAxisInteraction.length) {
        onHighlightedAxisChange?.(nextAxisInteraction);
        onTooltipAxisChange?.(nextAxisInteraction);
        return;
      }
      if (
        prevAxisInteraction?.some(
          ({ axisId, dataIndex }, itemIndex) =>
            nextAxisInteraction[itemIndex].axisId !== axisId ||
            nextAxisInteraction[itemIndex].dataIndex !== dataIndex,
        )
      ) {
        onHighlightedAxisChange?.(nextAxisInteraction);
        onTooltipAxisChange?.(nextAxisInteraction);
      }
    },
  );

  const hasInteractionPlugin = checkHasInteractionPlugin(instance);

  React.useEffect(() => {
    const element = svgRef.current;
    if (!isInteractionEnabled || !hasInteractionPlugin || !element || params.disableAxisListener) {
      return () => {};
    }

    // Clean the interaction when the mouse leaves the chart.
    const moveEndHandler = instance.addInteractionListener('moveEnd', (event) => {
      if (!event.detail.activeGestures.pan) {
        instance.cleanInteraction();
      }
    });
    const panEndHandler = instance.addInteractionListener('panEnd', (event) => {
      if (!event.detail.activeGestures.move) {
        instance.cleanInteraction();
      }
    });
    const pressEndHandler = instance.addInteractionListener('quickPressEnd', (event) => {
      if (!event.detail.activeGestures.move && !event.detail.activeGestures.pan) {
        instance.cleanInteraction();
      }
    });

    const gestureHandler = (event: CustomEvent<PointerGestureEventData>) => {
      const srvEvent = event.detail.srcEvent;
      const target = event.detail.target as SVGElement | undefined;
      const svgPoint = getChartPoint(element, srvEvent);

      // Release the pointer capture if we are panning, as this would cause the tooltip to
      // be locked to the first "section" it touches.
      if (
        event.detail.srcEvent.buttons >= 1 &&
        target?.hasPointerCapture(event.detail.srcEvent.pointerId) &&
        !target?.closest('[data-charts-zoom-slider]')
      ) {
        target?.releasePointerCapture(event.detail.srcEvent.pointerId);
      }
      if (!instance.isPointInside(svgPoint.x, svgPoint.y, target)) {
        instance.cleanInteraction?.();

        return;
      }
      instance.setPointerCoordinate(svgPoint);
    };

    const moveHandler = instance.addInteractionListener('move', gestureHandler);
    const panHandler = instance.addInteractionListener('pan', gestureHandler);
    const pressHandler = instance.addInteractionListener('quickPress', gestureHandler);

    return () => {
      moveHandler.cleanup();
      moveEndHandler.cleanup();
      panHandler.cleanup();
      panEndHandler.cleanup();
      pressHandler.cleanup();
      pressEndHandler.cleanup();
    };
  }, [
    svgRef,
    store,
    xAxisWithScale,
    usedXAxis,
    yAxisWithScale,
    usedYAxis,
    instance,
    params.disableAxisListener,
    isInteractionEnabled,
    hasInteractionPlugin,
  ]);

  React.useEffect(() => {
    const element = svgRef.current;
    const onAxisClick = params.onAxisClick;
    if (element === null || !onAxisClick) {
      return () => {};
    }

    const axisClickHandler = instance.addInteractionListener('tap', (event) => {
      let dataIndex: number | null = null;
      let isXAxis: boolean = false;

      const svgPoint = getChartPoint(element, event.detail.srcEvent);

      const xIndex = getAxisIndex(xAxisWithScale[usedXAxis], svgPoint.x);
      isXAxis = xIndex !== -1;

      dataIndex = isXAxis ? xIndex : getAxisIndex(yAxisWithScale[usedYAxis], svgPoint.y);

      const USED_AXIS_ID = isXAxis ? xAxisIds[0] : yAxisIds[0];
      if (dataIndex == null || dataIndex === -1) {
        return;
      }

      // The .data exist because otherwise the dataIndex would be null or -1.
      const axisValue = (isXAxis ? xAxisWithScale : yAxisWithScale)[USED_AXIS_ID].data![dataIndex];

      const seriesValues: ChartsAxisData['seriesValues'] = {};

      Object.keys(processedSeries)
        .filter((seriesType): seriesType is AxisClickSeriesType =>
          AXIS_CLICK_SERIES_TYPES.has(seriesType as AxisClickSeriesType),
        )
        .forEach((seriesType) => {
          // @ts-ignore
          const seriesTypeConfig = processedSeries[seriesType];

          seriesTypeConfig?.seriesOrder.forEach((seriesId: SeriesId) => {
            const seriesItem = seriesTypeConfig!.series[seriesId];

            const providedXAxisId = seriesItem.xAxisId;
            const providedYAxisId = seriesItem.yAxisId;

            const axisKey = isXAxis ? providedXAxisId : providedYAxisId;
            if (axisKey === undefined || axisKey === USED_AXIS_ID) {
              // @ts-ignore This is safe because users need to opt in to use range bar series.
              // In that case, they should import the module augmentation from `x-charts-pro/moduleAugmentation/rangeBarOnClick`
              // Which adds the proper type to the series data.
              // TODO(v9): Remove this ts-ignore when we can make the breaking change to ChartsAxisData.
              seriesValues[seriesId] = seriesItem.data[dataIndex];
            }
          });
        });

      onAxisClick(event.detail.srcEvent, { dataIndex, axisValue, seriesValues });
    });

    return () => {
      axisClickHandler.cleanup();
    };
  }, [
    params.onAxisClick,
    processedSeries,
    svgRef,
    xAxisWithScale,
    xAxisIds,
    yAxisWithScale,
    yAxisIds,
    usedXAxis,
    usedYAxis,
    instance,
  ]);

  return {};
};

useChartCartesianAxis.params = {
  xAxis: true,
  yAxis: true,
  dataset: true,
  onAxisClick: true,
  disableAxisListener: true,
  onHighlightedAxisChange: true,
  highlightedAxis: true,
  onTooltipAxisChange: true,
  tooltipAxis: true,
  axesGap: true,
};

useChartCartesianAxis.getDefaultizedParams = ({ params }) => {
  return {
    ...params,
    axesGap: params.axesGap ?? 0,
    colors: params.colors ?? rainbowSurgePalette,
    theme: params.theme ?? 'light',
    defaultizedXAxis: defaultizeXAxis(params.xAxis, params.dataset, params.axesGap ?? 0),
    defaultizedYAxis: defaultizeYAxis(params.yAxis, params.dataset, params.axesGap ?? 0),
  };
};

useChartCartesianAxis.getInitialState = (params) => ({
  cartesianAxis: {
    axesGap: params.axesGap,
    x: params.defaultizedXAxis,
    y: params.defaultizedYAxis,
  },
  ...(params.highlightedAxis === undefined
    ? {}
    : {
        controlledCartesianAxisHighlight: params.highlightedAxis,
      }),
});
