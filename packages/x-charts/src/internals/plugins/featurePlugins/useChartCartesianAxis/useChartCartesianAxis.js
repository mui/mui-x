"use strict";
'use client';
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useChartCartesianAxis = void 0;
var React = require("react");
var useEnhancedEffect_1 = require("@mui/utils/useEnhancedEffect");
var store_1 = require("@mui/x-internals/store");
var useAssertModelConsistency_1 = require("@mui/x-internals/useAssertModelConsistency");
var warning_1 = require("@mui/x-internals/warning");
var colorPalettes_1 = require("../../../../colorPalettes");
var useChartDimensions_selectors_1 = require("../../corePlugins/useChartDimensions/useChartDimensions.selectors");
var useChartSeries_selectors_1 = require("../../corePlugins/useChartSeries/useChartSeries.selectors");
var defaultizeAxis_1 = require("./defaultizeAxis");
var useChartCartesianAxisRendering_selectors_1 = require("./useChartCartesianAxisRendering.selectors");
var getAxisValue_1 = require("./getAxisValue");
var getSVGPoint_1 = require("../../../getSVGPoint");
var useChartInteraction_1 = require("../useChartInteraction");
var useChartCartesianInteraction_selectors_1 = require("./useChartCartesianInteraction.selectors");
var checkHasInteractionPlugin_1 = require("../useChartInteraction/checkHasInteractionPlugin");
var AXIS_CLICK_SERIES_TYPES = new Set(['bar', 'rangeBar', 'line']);
var useChartCartesianAxis = function (_a) {
    var params = _a.params, store = _a.store, instance = _a.instance;
    var svgRef = instance.svgRef;
    var xAxis = params.xAxis, yAxis = params.yAxis, dataset = params.dataset, onHighlightedAxisChange = params.onHighlightedAxisChange, axesGap = params.axesGap;
    if (process.env.NODE_ENV !== 'production') {
        var ids_1 = __spreadArray(__spreadArray([], (xAxis !== null && xAxis !== void 0 ? xAxis : []), true), (yAxis !== null && yAxis !== void 0 ? yAxis : []), true).filter(function (axis) { return axis.id; })
            .map(function (axis) { return axis.id; });
        var duplicates = new Set(ids_1.filter(function (id, index) { return ids_1.indexOf(id) !== index; }));
        if (duplicates.size > 0) {
            (0, warning_1.warnOnce)([
                "MUI X Charts: The following axis ids are duplicated: ".concat(Array.from(duplicates).join(', '), "."),
                "Please make sure that each axis has a unique id.",
            ].join('\n'), 'error');
        }
    }
    var drawingArea = store.use(useChartDimensions_selectors_1.selectorChartDrawingArea);
    var processedSeries = store.use(useChartSeries_selectors_1.selectorChartSeriesProcessed);
    var isInteractionEnabled = store.use(useChartInteraction_1.selectorChartsInteractionIsInitialized);
    var _b = store.use(useChartCartesianAxisRendering_selectors_1.selectorChartXAxis), xAxisWithScale = _b.axis, xAxisIds = _b.axisIds;
    var _c = store.use(useChartCartesianAxisRendering_selectors_1.selectorChartYAxis), yAxisWithScale = _c.axis, yAxisIds = _c.axisIds;
    (0, useAssertModelConsistency_1.useAssertModelConsistency)({
        warningPrefix: 'MUI X Charts',
        componentName: 'Chart',
        propName: 'highlightedAxis',
        controlled: params.highlightedAxis,
        defaultValue: undefined,
    });
    (0, useEnhancedEffect_1.default)(function () {
        if (params.highlightedAxis !== undefined) {
            store.set('controlledCartesianAxisHighlight', params.highlightedAxis);
        }
    }, [store, params.highlightedAxis]);
    // The effect do not track any value defined synchronously during the 1st render by hooks called after `useChartCartesianAxis`
    // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one
    var isFirstRender = React.useRef(true);
    React.useEffect(function () {
        if (isFirstRender.current) {
            isFirstRender.current = false;
            return;
        }
        store.set('cartesianAxis', {
            axesGap: axesGap,
            x: (0, defaultizeAxis_1.defaultizeXAxis)(xAxis, dataset, axesGap),
            y: (0, defaultizeAxis_1.defaultizeYAxis)(yAxis, dataset, axesGap),
        });
    }, [drawingArea, xAxis, yAxis, dataset, axesGap, store]);
    var usedXAxis = xAxisIds[0];
    var usedYAxis = yAxisIds[0];
    (0, store_1.useStoreEffect)(store, useChartCartesianInteraction_selectors_1.selectorChartAxisInteraction, function (prevAxisInteraction, nextAxisInteraction) {
        if (!onHighlightedAxisChange) {
            return;
        }
        if (Object.is(prevAxisInteraction, nextAxisInteraction)) {
            return;
        }
        if (prevAxisInteraction.length !== nextAxisInteraction.length) {
            onHighlightedAxisChange(nextAxisInteraction);
            return;
        }
        if (prevAxisInteraction === null || prevAxisInteraction === void 0 ? void 0 : prevAxisInteraction.some(function (_a, itemIndex) {
            var axisId = _a.axisId, dataIndex = _a.dataIndex;
            return nextAxisInteraction[itemIndex].axisId !== axisId ||
                nextAxisInteraction[itemIndex].dataIndex !== dataIndex;
        })) {
            onHighlightedAxisChange(nextAxisInteraction);
        }
    });
    var hasInteractionPlugin = (0, checkHasInteractionPlugin_1.checkHasInteractionPlugin)(instance);
    React.useEffect(function () {
        var element = svgRef.current;
        if (!isInteractionEnabled || !hasInteractionPlugin || !element || params.disableAxisListener) {
            return function () { };
        }
        // Clean the interaction when the mouse leaves the chart.
        var moveEndHandler = instance.addInteractionListener('moveEnd', function (event) {
            if (!event.detail.activeGestures.pan) {
                instance.cleanInteraction();
            }
        });
        var panEndHandler = instance.addInteractionListener('panEnd', function (event) {
            if (!event.detail.activeGestures.move) {
                instance.cleanInteraction();
            }
        });
        var pressEndHandler = instance.addInteractionListener('quickPressEnd', function (event) {
            if (!event.detail.activeGestures.move && !event.detail.activeGestures.pan) {
                instance.cleanInteraction();
            }
        });
        var gestureHandler = function (event) {
            var _a;
            var srvEvent = event.detail.srcEvent;
            var target = event.detail.target;
            var svgPoint = (0, getSVGPoint_1.getSVGPoint)(element, srvEvent);
            // Release the pointer capture if we are panning, as this would cause the tooltip to
            // be locked to the first "section" it touches.
            if (event.detail.srcEvent.buttons >= 1 &&
                (target === null || target === void 0 ? void 0 : target.hasPointerCapture(event.detail.srcEvent.pointerId)) &&
                !(target === null || target === void 0 ? void 0 : target.closest('[data-charts-zoom-slider]'))) {
                target === null || target === void 0 ? void 0 : target.releasePointerCapture(event.detail.srcEvent.pointerId);
            }
            if (!instance.isPointInside(svgPoint.x, svgPoint.y, target)) {
                (_a = instance.cleanInteraction) === null || _a === void 0 ? void 0 : _a.call(instance);
                return;
            }
            instance.setPointerCoordinate(svgPoint);
        };
        var moveHandler = instance.addInteractionListener('move', gestureHandler);
        var panHandler = instance.addInteractionListener('pan', gestureHandler);
        var pressHandler = instance.addInteractionListener('quickPress', gestureHandler);
        return function () {
            moveHandler.cleanup();
            moveEndHandler.cleanup();
            panHandler.cleanup();
            panEndHandler.cleanup();
            pressHandler.cleanup();
            pressEndHandler.cleanup();
        };
    }, [
        svgRef,
        store,
        xAxisWithScale,
        usedXAxis,
        yAxisWithScale,
        usedYAxis,
        instance,
        params.disableAxisListener,
        isInteractionEnabled,
        hasInteractionPlugin,
    ]);
    React.useEffect(function () {
        var element = svgRef.current;
        var onAxisClick = params.onAxisClick;
        if (element === null || !onAxisClick) {
            return function () { };
        }
        var axisClickHandler = instance.addInteractionListener('tap', function (event) {
            var dataIndex = null;
            var isXAxis = false;
            var svgPoint = (0, getSVGPoint_1.getSVGPoint)(element, event.detail.srcEvent);
            var xIndex = (0, getAxisValue_1.getAxisIndex)(xAxisWithScale[usedXAxis], svgPoint.x);
            isXAxis = xIndex !== -1;
            dataIndex = isXAxis ? xIndex : (0, getAxisValue_1.getAxisIndex)(yAxisWithScale[usedYAxis], svgPoint.y);
            var USED_AXIS_ID = isXAxis ? xAxisIds[0] : yAxisIds[0];
            if (dataIndex == null || dataIndex === -1) {
                return;
            }
            // The .data exist because otherwise the dataIndex would be null or -1.
            var axisValue = (isXAxis ? xAxisWithScale : yAxisWithScale)[USED_AXIS_ID].data[dataIndex];
            var seriesValues = {};
            Object.keys(processedSeries)
                .filter(function (seriesType) {
                return AXIS_CLICK_SERIES_TYPES.has(seriesType);
            })
                .forEach(function (seriesType) {
                // @ts-ignore
                var seriesTypeConfig = processedSeries[seriesType];
                seriesTypeConfig === null || seriesTypeConfig === void 0 ? void 0 : seriesTypeConfig.seriesOrder.forEach(function (seriesId) {
                    var seriesItem = seriesTypeConfig.series[seriesId];
                    var providedXAxisId = seriesItem.xAxisId;
                    var providedYAxisId = seriesItem.yAxisId;
                    var axisKey = isXAxis ? providedXAxisId : providedYAxisId;
                    if (axisKey === undefined || axisKey === USED_AXIS_ID) {
                        // @ts-ignore This is safe because users need to opt in to use range bar series.
                        // In that case, they should import the module augmentation from `x-charts-pro/moduleAugmentation/rangeBarOnClick`
                        // Which adds the proper type to the series data.
                        // TODO(v9): Remove this ts-ignore when we can make the breaking change to ChartsAxisData.
                        seriesValues[seriesId] = seriesItem.data[dataIndex];
                    }
                });
            });
            onAxisClick(event.detail.srcEvent, { dataIndex: dataIndex, axisValue: axisValue, seriesValues: seriesValues });
        });
        return function () {
            axisClickHandler.cleanup();
        };
    }, [
        params.onAxisClick,
        processedSeries,
        svgRef,
        xAxisWithScale,
        xAxisIds,
        yAxisWithScale,
        yAxisIds,
        usedXAxis,
        usedYAxis,
        instance,
    ]);
    return {};
};
exports.useChartCartesianAxis = useChartCartesianAxis;
exports.useChartCartesianAxis.params = {
    xAxis: true,
    yAxis: true,
    dataset: true,
    onAxisClick: true,
    disableAxisListener: true,
    onHighlightedAxisChange: true,
    highlightedAxis: true,
    axesGap: true,
};
exports.useChartCartesianAxis.getDefaultizedParams = function (_a) {
    var _b, _c, _d, _e, _f;
    var params = _a.params;
    return __assign(__assign({}, params), { axesGap: (_b = params.axesGap) !== null && _b !== void 0 ? _b : 0, colors: (_c = params.colors) !== null && _c !== void 0 ? _c : colorPalettes_1.rainbowSurgePalette, theme: (_d = params.theme) !== null && _d !== void 0 ? _d : 'light', defaultizedXAxis: (0, defaultizeAxis_1.defaultizeXAxis)(params.xAxis, params.dataset, (_e = params.axesGap) !== null && _e !== void 0 ? _e : 0), defaultizedYAxis: (0, defaultizeAxis_1.defaultizeYAxis)(params.yAxis, params.dataset, (_f = params.axesGap) !== null && _f !== void 0 ? _f : 0) });
};
exports.useChartCartesianAxis.getInitialState = function (params) { return (__assign({ cartesianAxis: {
        axesGap: params.axesGap,
        x: params.defaultizedXAxis,
        y: params.defaultizedYAxis,
    } }, (params.highlightedAxis === undefined
    ? {}
    : {
        controlledCartesianAxisHighlight: params.highlightedAxis,
    }))); };
