"use strict";
'use client';
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useChartCartesianAxis = void 0;
var React = require("react");
var useEnhancedEffect_1 = require("@mui/utils/useEnhancedEffect");
var useAssertModelConsistency_1 = require("@mui/x-internals/useAssertModelConsistency");
var warning_1 = require("@mui/x-internals/warning");
var colorPalettes_1 = require("../../../../colorPalettes");
var useSelector_1 = require("../../../store/useSelector");
var useChartDimensions_selectors_1 = require("../../corePlugins/useChartDimensions/useChartDimensions.selectors");
var useChartSeries_selectors_1 = require("../../corePlugins/useChartSeries/useChartSeries.selectors");
var defaultizeAxis_1 = require("./defaultizeAxis");
var useChartCartesianAxisRendering_selectors_1 = require("./useChartCartesianAxisRendering.selectors");
var getAxisValue_1 = require("./getAxisValue");
var getSVGPoint_1 = require("../../../getSVGPoint");
var useChartInteraction_1 = require("../useChartInteraction");
var useChartCartesianInteraction_selectors_1 = require("./useChartCartesianInteraction.selectors");
var useLazySelectorEffect_1 = require("../../utils/useLazySelectorEffect");
var useChartCartesianAxis = function (_a) {
    var params = _a.params, store = _a.store, seriesConfig = _a.seriesConfig, svgRef = _a.svgRef, instance = _a.instance;
    var xAxis = params.xAxis, yAxis = params.yAxis, dataset = params.dataset, onHighlightedAxisChange = params.onHighlightedAxisChange;
    if (process.env.NODE_ENV !== 'production') {
        var ids_1 = __spreadArray(__spreadArray([], (xAxis !== null && xAxis !== void 0 ? xAxis : []), true), (yAxis !== null && yAxis !== void 0 ? yAxis : []), true).filter(function (axis) { return axis.id; })
            .map(function (axis) { return axis.id; });
        var duplicates = new Set(ids_1.filter(function (id, index) { return ids_1.indexOf(id) !== index; }));
        if (duplicates.size > 0) {
            (0, warning_1.warnOnce)([
                "MUI X Charts: The following axis ids are duplicated: ".concat(Array.from(duplicates).join(', '), "."),
                "Please make sure that each axis has a unique id.",
            ].join('\n'), 'error');
        }
    }
    var drawingArea = (0, useSelector_1.useSelector)(store, useChartDimensions_selectors_1.selectorChartDrawingArea);
    var processedSeries = (0, useSelector_1.useSelector)(store, useChartSeries_selectors_1.selectorChartSeriesProcessed);
    var isInteractionEnabled = (0, useSelector_1.useSelector)(store, useChartInteraction_1.selectorChartsInteractionIsInitialized);
    var _b = (0, useSelector_1.useSelector)(store, useChartCartesianAxisRendering_selectors_1.selectorChartXAxis), xAxisWithScale = _b.axis, xAxisIds = _b.axisIds;
    var _c = (0, useSelector_1.useSelector)(store, useChartCartesianAxisRendering_selectors_1.selectorChartYAxis), yAxisWithScale = _c.axis, yAxisIds = _c.axisIds;
    (0, useAssertModelConsistency_1.useAssertModelConsistency)({
        warningPrefix: 'MUI X Charts',
        componentName: 'Chart',
        propName: 'highlightedAxis',
        controlled: params.highlightedAxis,
        defaultValue: undefined,
    });
    (0, useEnhancedEffect_1.default)(function () {
        if (params.highlightedAxis !== undefined) {
            store.update(function (prevState) {
                if (prevState.controlledCartesianAxisHighlight === params.highlightedAxis) {
                    return prevState;
                }
                return __assign(__assign({}, prevState), { controlledCartesianAxisHighlight: params.highlightedAxis });
            });
        }
    }, [store, params.highlightedAxis]);
    // The effect do not track any value defined synchronously during the 1st render by hooks called after `useChartCartesianAxis`
    // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one
    var isFirstRender = React.useRef(true);
    React.useEffect(function () {
        if (isFirstRender.current) {
            isFirstRender.current = false;
            return;
        }
        store.update(function (prev) { return (__assign(__assign({}, prev), { cartesianAxis: __assign(__assign({}, prev.cartesianAxis), { x: (0, defaultizeAxis_1.defaultizeXAxis)(xAxis, dataset), y: (0, defaultizeAxis_1.defaultizeYAxis)(yAxis, dataset) }) })); });
    }, [seriesConfig, drawingArea, xAxis, yAxis, dataset, store]);
    var usedXAxis = xAxisIds[0];
    var usedYAxis = yAxisIds[0];
    (0, useLazySelectorEffect_1.useLazySelectorEffect)(store, useChartCartesianInteraction_selectors_1.selectorChartAxisInteraction, function (prevAxisInteraction, nextAxisInteraction) {
        if (Object.is(prevAxisInteraction, nextAxisInteraction)) {
            return;
        }
        if (prevAxisInteraction.length !== nextAxisInteraction.length) {
            onHighlightedAxisChange(nextAxisInteraction);
            return;
        }
        if (prevAxisInteraction === null || prevAxisInteraction === void 0 ? void 0 : prevAxisInteraction.some(function (_a, itemIndex) {
            var axisId = _a.axisId, dataIndex = _a.dataIndex;
            return nextAxisInteraction[itemIndex].axisId !== axisId ||
                nextAxisInteraction[itemIndex].dataIndex !== dataIndex;
        })) {
            onHighlightedAxisChange(nextAxisInteraction);
        }
    }, !onHighlightedAxisChange);
    React.useEffect(function () {
        var element = svgRef.current;
        if (!isInteractionEnabled || !element || params.disableAxisListener) {
            return function () { };
        }
        // Clean the interaction when the mouse leaves the chart.
        var moveEndHandler = instance.addInteractionListener('moveEnd', function (event) {
            var _a;
            if (!event.detail.activeGestures.pan) {
                (_a = instance.cleanInteraction) === null || _a === void 0 ? void 0 : _a.call(instance);
            }
        });
        var panEndHandler = instance.addInteractionListener('panEnd', function (event) {
            var _a;
            if (!event.detail.activeGestures.move) {
                (_a = instance.cleanInteraction) === null || _a === void 0 ? void 0 : _a.call(instance);
            }
        });
        var pressEndHandler = instance.addInteractionListener('quickPressEnd', function (event) {
            var _a;
            if (!event.detail.activeGestures.move && !event.detail.activeGestures.pan) {
                (_a = instance.cleanInteraction) === null || _a === void 0 ? void 0 : _a.call(instance);
            }
        });
        var gestureHandler = function (event) {
            var _a, _b;
            var srvEvent = event.detail.srcEvent;
            var target = event.detail.target;
            var svgPoint = (0, getSVGPoint_1.getSVGPoint)(element, srvEvent);
            // Release the pointer capture if we are panning, as this would cause the tooltip to
            // be locked to the first "section" it touches.
            if (event.detail.srcEvent.buttons >= 1 &&
                (target === null || target === void 0 ? void 0 : target.hasPointerCapture(event.detail.srcEvent.pointerId)) &&
                !(target === null || target === void 0 ? void 0 : target.closest('[data-charts-zoom-slider]'))) {
                target === null || target === void 0 ? void 0 : target.releasePointerCapture(event.detail.srcEvent.pointerId);
            }
            if (!instance.isPointInside(svgPoint.x, svgPoint.y, target)) {
                (_a = instance.cleanInteraction) === null || _a === void 0 ? void 0 : _a.call(instance);
                return;
            }
            (_b = instance.setPointerCoordinate) === null || _b === void 0 ? void 0 : _b.call(instance, svgPoint);
        };
        var moveHandler = instance.addInteractionListener('move', gestureHandler);
        var panHandler = instance.addInteractionListener('pan', gestureHandler);
        var pressHandler = instance.addInteractionListener('quickPress', gestureHandler);
        return function () {
            moveHandler.cleanup();
            moveEndHandler.cleanup();
            panHandler.cleanup();
            panEndHandler.cleanup();
            pressHandler.cleanup();
            pressEndHandler.cleanup();
        };
    }, [
        svgRef,
        store,
        xAxisWithScale,
        usedXAxis,
        yAxisWithScale,
        usedYAxis,
        instance,
        params.disableAxisListener,
        isInteractionEnabled,
    ]);
    React.useEffect(function () {
        var element = svgRef.current;
        var onAxisClick = params.onAxisClick;
        if (element === null || !onAxisClick) {
            return function () { };
        }
        var axisClickHandler = instance.addInteractionListener('tap', function (event) {
            var dataIndex = null;
            var isXAxis = false;
            var svgPoint = (0, getSVGPoint_1.getSVGPoint)(element, event.detail.srcEvent);
            var xIndex = (0, getAxisValue_1.getAxisIndex)(xAxisWithScale[usedXAxis], svgPoint.x);
            isXAxis = xIndex !== -1;
            dataIndex = isXAxis ? xIndex : (0, getAxisValue_1.getAxisIndex)(yAxisWithScale[usedYAxis], svgPoint.y);
            var USED_AXIS_ID = isXAxis ? xAxisIds[0] : yAxisIds[0];
            if (dataIndex == null || dataIndex === -1) {
                return;
            }
            // The .data exist because otherwise the dataIndex would be null or -1.
            var axisValue = (isXAxis ? xAxisWithScale : yAxisWithScale)[USED_AXIS_ID].data[dataIndex];
            var seriesValues = {};
            Object.keys(processedSeries)
                .filter(function (seriesType) { return ['bar', 'line'].includes(seriesType); })
                .forEach(function (seriesType) {
                var _a;
                (_a = processedSeries[seriesType]) === null || _a === void 0 ? void 0 : _a.seriesOrder.forEach(function (seriesId) {
                    var seriesItem = processedSeries[seriesType].series[seriesId];
                    var providedXAxisId = seriesItem.xAxisId;
                    var providedYAxisId = seriesItem.yAxisId;
                    var axisKey = isXAxis ? providedXAxisId : providedYAxisId;
                    if (axisKey === undefined || axisKey === USED_AXIS_ID) {
                        seriesValues[seriesId] = seriesItem.data[dataIndex];
                    }
                });
            });
            onAxisClick(event.detail.srcEvent, { dataIndex: dataIndex, axisValue: axisValue, seriesValues: seriesValues });
        });
        return function () {
            axisClickHandler.cleanup();
        };
    }, [
        params.onAxisClick,
        processedSeries,
        svgRef,
        xAxisWithScale,
        xAxisIds,
        yAxisWithScale,
        yAxisIds,
        usedXAxis,
        usedYAxis,
        instance,
    ]);
    return {};
};
exports.useChartCartesianAxis = useChartCartesianAxis;
exports.useChartCartesianAxis.params = {
    xAxis: true,
    yAxis: true,
    dataset: true,
    onAxisClick: true,
    disableAxisListener: true,
    onHighlightedAxisChange: true,
    highlightedAxis: true,
};
exports.useChartCartesianAxis.getDefaultizedParams = function (_a) {
    var _b, _c;
    var params = _a.params;
    return __assign(__assign({}, params), { colors: (_b = params.colors) !== null && _b !== void 0 ? _b : colorPalettes_1.rainbowSurgePalette, theme: (_c = params.theme) !== null && _c !== void 0 ? _c : 'light', defaultizedXAxis: (0, defaultizeAxis_1.defaultizeXAxis)(params.xAxis, params.dataset), defaultizedYAxis: (0, defaultizeAxis_1.defaultizeYAxis)(params.yAxis, params.dataset) });
};
exports.useChartCartesianAxis.getInitialState = function (params) { return (__assign({ cartesianAxis: {
        x: params.defaultizedXAxis,
        y: params.defaultizedYAxis,
    } }, (params.highlightedAxis === undefined
    ? {}
    : {
        controlledCartesianAxisHighlight: params.highlightedAxis,
    }))); };
