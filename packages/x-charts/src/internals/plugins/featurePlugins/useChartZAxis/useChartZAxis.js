"use strict";
'use client';
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useChartZAxis = void 0;
var React = require("react");
var colorScale_1 = require("../../../colorScale");
function addDefaultId(axisConfig, defaultId) {
    if (axisConfig.id !== undefined) {
        return axisConfig;
    }
    return __assign({ id: defaultId }, axisConfig);
}
function processColorMap(axisConfig) {
    if (!axisConfig.colorMap) {
        return axisConfig;
    }
    return __assign(__assign({}, axisConfig), { colorScale: axisConfig.colorMap.type === 'ordinal' && axisConfig.data
            ? (0, colorScale_1.getOrdinalColorScale)(__assign({ values: axisConfig.data }, axisConfig.colorMap))
            : (0, colorScale_1.getColorScale)(axisConfig.colorMap.type === 'continuous'
                ? __assign({ min: axisConfig.min, max: axisConfig.max }, axisConfig.colorMap) : axisConfig.colorMap) });
}
function getZAxisState(zAxis, dataset) {
    if (!zAxis || zAxis.length === 0) {
        return { axis: {}, axisIds: [] };
    }
    var zAxisLookup = {};
    var axisIds = [];
    zAxis.forEach(function (axisConfig, index) {
        var _a;
        var dataKey = axisConfig.dataKey;
        var defaultizedId = (_a = axisConfig.id) !== null && _a !== void 0 ? _a : "defaultized-z-axis-".concat(index);
        if (dataKey === undefined || axisConfig.data !== undefined) {
            zAxisLookup[defaultizedId] = processColorMap(addDefaultId(axisConfig, defaultizedId));
            axisIds.push(defaultizedId);
            return;
        }
        if (dataset === undefined) {
            throw new Error('MUI X Charts: z-axis uses `dataKey` but no `dataset` is provided.');
        }
        zAxisLookup[defaultizedId] = processColorMap(addDefaultId(__assign(__assign({}, axisConfig), { data: dataset.map(function (d) { return d[dataKey]; }) }), defaultizedId));
        axisIds.push(defaultizedId);
    });
    return { axis: zAxisLookup, axisIds: axisIds };
}
var useChartZAxis = function (_a) {
    var params = _a.params, store = _a.store;
    var zAxis = params.zAxis, dataset = params.dataset;
    // The effect do not track any value defined synchronously during the 1st render by hooks called after `useChartZAxis`
    // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one
    var isFirstRender = React.useRef(true);
    React.useEffect(function () {
        if (isFirstRender.current) {
            isFirstRender.current = false;
            return;
        }
        store.update(function (prev) { return (__assign(__assign({}, prev), { zAxis: getZAxisState(zAxis, dataset) })); });
    }, [zAxis, dataset, store]);
    return {};
};
exports.useChartZAxis = useChartZAxis;
exports.useChartZAxis.params = {
    zAxis: true,
    dataset: true,
};
exports.useChartZAxis.getInitialState = function (params) { return ({
    zAxis: getZAxisState(params.zAxis, params.dataset),
}); };
