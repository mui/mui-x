'use client';
import { useEffectAfterFirstRender } from '@mui/x-internals/useEffectAfterFirstRender';
import { type ChartPlugin } from '../../models';
import type { UseChartSeriesState, UseChartSeriesSignature } from './useChartSeries.types';
import { rainbowSurgePalette } from '../../../../colorPalettes';
import { defaultizeSeries } from './processSeries';
import { type ChartSeriesType } from '../../../../models/seriesType/config';
import type {
  SeriesItemIdentifier,
  SeriesItemIdentifierWithType,
  SeriesId,
} from '../../../../models/seriesType';

type RetrunedType<
  SeriesType extends ChartSeriesType,
  Item,
> = Item extends SeriesItemIdentifier<SeriesType>
  ? SeriesItemIdentifierWithType<SeriesType>
  : Item & { type: SeriesType }

export function createIdentifierWithType(state: UseChartSeriesState) {
  function identifierWithType<
    SeriesType extends ChartSeriesType,
    Item extends { seriesId: SeriesId; type?: SeriesType },
  >(
    identifier: Item,
  ): RetrunedType<SeriesType, Item> {
    if (identifier.type !== undefined) {
      return identifier as RetrunedType<SeriesType, Item>;
    }
    const type = state.series.idToType.get(identifier.seriesId);

    if (type === undefined) {
      throw new Error(`MUI X Charts: id "${identifier.seriesId}" is not a series id.`);
    }
    return { ...identifier, type } as RetrunedType<SeriesType, Item>;
  }

  return identifierWithType;
}

export const useChartSeries: ChartPlugin<UseChartSeriesSignature> = ({ params, store }) => {
  const { series, dataset, theme, colors } = params;

  // The effect do not track any value defined synchronously during the 1st render by hooks called after `useChartSeries`
  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one
  useEffectAfterFirstRender(() => {
    const { defaultizedSeries, idToType } = defaultizeSeries({
      series,
      colors: typeof colors === 'function' ? colors(theme) : colors,
      seriesConfig: store.state.seriesConfig.config,
    });
    store.set('series', {
      ...store.state.series,
      defaultizedSeries,
      idToType,
      dataset,
    });
  }, [colors, dataset, series, theme, store]);

  const identifierWithType = createIdentifierWithType(store.state);

  return { instance: { identifierWithType } };
};

useChartSeries.params = {
  dataset: true,
  series: true,
  colors: true,
  theme: true,
};

const EMPTY_ARRAY: any[] = [];

useChartSeries.getDefaultizedParams = ({ params }) => ({
  ...params,
  series: params.series?.length ? params.series : EMPTY_ARRAY,
  colors: params.colors ?? rainbowSurgePalette,
  theme: params.theme ?? 'light',
});

useChartSeries.getInitialState = ({ series = [], colors, theme, dataset }, currentState) => {
  const seriesConfig = currentState.seriesConfig.config;
  const { defaultizedSeries, idToType } = defaultizeSeries({
    series,
    colors: typeof colors === 'function' ? colors(theme) : colors,
    seriesConfig,
  });
  return {
    series: {
      defaultizedSeries,
      idToType,
      dataset,
    },
  };
};
