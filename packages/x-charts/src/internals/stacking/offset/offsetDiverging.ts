import type { Series } from '@mui/x-charts-vendor/d3-shape';

// Adapted from D3.js's offsetDiverging function https://github.com/d3/d3-shape/blob/main/src/offset/diverging.js
// Hidden series (with all zero values) affect the stacking in a different way in our implementation compared to the D3 behavior.
// The D3 stacking keep those values at the 0 "line", which creates issues when animating between hidden and visible states.
// In our modification, we stack them on top/below already stacked items according to the sign of their original value.
// A hidden negative value will be placed below all the already stacked negative values

/**
 * Positive values are stacked above zero, while negative values are stacked below zero.
 *
 * @param series A series generated by a stack generator.
 * @param order An array of numeric indexes representing the stack order.
 */
export function offsetDiverging(series: Series<any, any>[], order: Iterable<number>) {
  if (series.length === 0) {
    return;
  }

  const seriesCount = series.length;
  const numericOrder = order as number[];
  const pointCount = series[numericOrder[0]].length;

  for (let pointIndex = 0; pointIndex < pointCount; pointIndex += 1) {
    let positiveSum = 0;
    let negativeSum = 0;

    for (let seriesIndex = 0; seriesIndex < seriesCount; seriesIndex += 1) {
      const currentSeries = series[numericOrder[seriesIndex]];
      const dataPoint = currentSeries[pointIndex];
      const difference = dataPoint[1] - dataPoint[0];

      if (difference > 0) {
        dataPoint[0] = positiveSum;
        positiveSum += difference;
        dataPoint[1] = positiveSum;
      } else if (difference < 0) {
        dataPoint[1] = negativeSum;
        negativeSum += difference;
        dataPoint[0] = negativeSum;
      } else if (dataPoint.data[currentSeries.key] > 0) {
        dataPoint[0] = positiveSum;
        dataPoint[1] = positiveSum;
      } else if (dataPoint.data[currentSeries.key] < 0) {
        dataPoint[1] = negativeSum;
        dataPoint[0] = negativeSum;
      } else {
        dataPoint[0] = 0;
        dataPoint[1] = 0;
      }
    }
  }
}
