import * as React from 'react';
import useEventCallback from '@mui/utils/useEventCallback';
import { useRtl } from '@mui/system/RtlProvider';
import { RefObject } from '@mui/x-internals/types';
import { useVirtualizer, Virtualization, EMPTY_RENDER_CONTEXT } from '@mui/x-virtualizer';
import { isJSDOM } from '../../../utils/isJSDOM';
import { useFirstRender } from '../../utils/useFirstRender';
import { GridApiCommunity, GridPrivateApiCommunity } from '../../../models/api/gridApiCommunity';
import { useGridApiMethod } from '../../utils/useGridApiMethod';
import { GridStateInitializer } from '../../utils/useGridInitializeState';
import {
  gridDimensionsSelector,
  gridColumnsTotalWidthSelector,
  gridContentHeightSelector,
  gridHasFillerSelector,
  gridRowHeightSelector,
  gridVerticalScrollbarWidthSelector,
} from '../dimensions/gridDimensionsSelectors';
import { useGridRootProps } from '../../utils/useGridRootProps';
import { useGridSelector } from '../../utils/useGridSelector';
import {
  gridVisibleColumnDefinitionsSelector,
  gridVisiblePinnedColumnDefinitionsSelector,
  gridColumnPositionsSelector,
  gridHasColSpanSelector,
} from '../columns/gridColumnsSelector';
import { gridPinnedRowsSelector, gridRowTreeSelector } from '../rows/gridRowsSelector';
import { useGridVisibleRows, getVisibleRows } from '../../utils/useGridVisibleRows';
import { useGridEventPriority } from '../../utils';
import { DataGridProcessedProps } from '../../../models/props/DataGridProps';
import { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';
import { gridRowSpanningHiddenCellsOriginMapSelector } from '../rows/gridRowSpanningSelectors';
import { gridListColumnSelector } from '../listView/gridListViewSelectors';
import { minimalContentHeight } from '../rows/gridRowsUtils';
import { EMPTY_PINNED_COLUMN_FIELDS, GridPinnedColumns } from '../columns';
import { gridFocusedVirtualCellSelector } from './gridFocusedVirtualCellSelector';
import { gridRowSelectionManagerSelector } from '../rowSelection';

const HAS_LAYOUT = !isJSDOM;

type RootProps = DataGridProcessedProps;

// HACK: Typescript doesn't use the alias name ("GridVirtualizationState") and changes
// the autogenerated docs result, but this would otherwise be just:
//   export type GridVirtualizationState = VirtualizationState;
export type GridVirtualizationState = {
  [K in keyof Virtualization.State['virtualization']]: Virtualization.State['virtualization'][K];
};

// XXX: We want to use the virtualizer as the source of truth for its state, but this needs to
// stay because some parts of the grid require the `virtualization` state during initialization.
export const virtualizationStateInitializer: GridStateInitializer<RootProps> = (state, props) => {
  const { disableVirtualization, autoHeight } = props;

  const virtualization = {
    enabled: !disableVirtualization && HAS_LAYOUT,
    enabledForColumns: !disableVirtualization && HAS_LAYOUT,
    enabledForRows: !disableVirtualization && !autoHeight && HAS_LAYOUT,
    renderContext: EMPTY_RENDER_CONTEXT,
  };

  return {
    ...state,
    virtualization,
  };
};

export function useGridVirtualization(
  apiRef: RefObject<GridPrivateApiCommunity>,
  rootProps: RootProps,
): void {
  /*
   * Virtualizer setup
   */

  const isRtl = useRtl();
  const { listView } = rootProps;
  const visibleColumns = useGridSelector(apiRef, () =>
    listView ? [gridListColumnSelector(apiRef)!] : gridVisibleColumnDefinitionsSelector(apiRef),
  );

  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);
  const pinnedColumns = listView
    ? (EMPTY_PINNED_COLUMN_FIELDS as unknown as GridPinnedColumns)
    : gridVisiblePinnedColumnDefinitionsSelector(apiRef);

  const rowSelectionManager = useGridSelector(apiRef, gridRowSelectionManagerSelector);
  const isRowSelected = (id: any) =>
    rowSelectionManager.has(id) && apiRef.current.isRowSelectable(id);

  const currentPage = useGridVisibleRows(apiRef);

  const hasColSpan = useGridSelector(apiRef, gridHasColSpanSelector);

  /* TODO: extract dimensions code */
  const rowHeight = useGridSelector(apiRef, gridRowHeightSelector);
  const contentHeight = useGridSelector(apiRef, gridContentHeightSelector);
  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);
  const needsHorizontalScrollbar = useGridSelector(apiRef, needsHorizontalScrollbarSelector);
  const verticalScrollbarWidth = useGridSelector(apiRef, gridVerticalScrollbarWidthSelector);
  const hasFiller = useGridSelector(apiRef, gridHasFillerSelector);
  const { autoHeight, disableVirtualization } = rootProps;

  const focusedVirtualCell = useGridSelector(apiRef, gridFocusedVirtualCellSelector);

  const scrollReset = listView;

  const virtualizer = useVirtualizer({
    initialState: {
      virtualization: apiRef.current.state.virtualization,
      scroll: rootProps.initialState?.scroll,
    },
    isRtl,
    rows: currentPage.rows,
    range: currentPage.range,
    columns: visibleColumns,
    pinnedRows,
    pinnedColumns,
    refs: {
      main: apiRef.current.mainElementRef,
      scroller: apiRef.current.virtualScrollerRef,
      scrollbarVertical: apiRef.current.virtualScrollbarVerticalRef,
      scrollbarHorizontal: apiRef.current.virtualScrollbarHorizontalRef,
    },
    hasColSpan,
    rowHeight,
    contentHeight,
    minimalContentHeight,
    columnsTotalWidth,
    needsHorizontalScrollbar: needsHorizontalScrollbar && !listView,
    autoHeight,

    focusedCell: focusedVirtualCell,
    rowBufferPx: rootProps.rowBufferPx,
    columnBufferPx: rootProps.columnBufferPx,

    onResize: useEventCallback((lastSize) => apiRef.current.publishEvent('resize', lastSize)),
    onWheel: useEventCallback((event: React.WheelEvent) => {
      apiRef.current.publishEvent('virtualScrollerWheel', {}, event);
    }),
    onTouchMove: useEventCallback((event: React.TouchEvent) => {
      apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);
    }),

    scrollReset,

    fixme: {
      dimensions: () => apiRef.current.state.dimensions,
      onContextChange: (nextRenderContext) =>
        apiRef.current.publishEvent('renderedRowsIntervalChange', nextRenderContext),
      inputs: (enabledForRows, enabledForColumns) =>
        inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns),
      onScrollChange: (scrollPosition, nextRenderContext) => {
        apiRef.current.publishEvent('scrollPositionChange', {
          top: scrollPosition.current.top,
          left: scrollPosition.current.left,
          renderContext: nextRenderContext,
        });
      },

      rowTree: () => gridRowTreeSelector(apiRef),
      columnPositions: () => gridColumnPositionsSelector(apiRef),

      calculateColSpan: (params) => apiRef.current.calculateColSpan(params),

      getRowHeight: (id) =>
        !apiRef.current.rowHasAutoHeight(id) ? apiRef.current.unstable_getRowHeight(id) : 'auto',

      renderRow: (params) => (
        <rootProps.slots.row
          key={params.id}
          row={params.model}
          rowId={params.id}
          index={params.rowIndex}
          selected={isRowSelected(params.id)}
          offsetLeft={params.offsetLeft}
          columnsTotalWidth={columnsTotalWidth}
          rowHeight={params.baseRowHeight}
          pinnedColumns={pinnedColumns}
          visibleColumns={params.columns}
          firstColumnIndex={params.firstColumnIndex}
          lastColumnIndex={params.lastColumnIndex}
          focusedColumnIndex={params.focusedColumnIndex}
          isFirstVisible={params.isFirstVisible}
          isLastVisible={params.isLastVisible}
          isNotVisible={params.isVirtualFocusRow}
          showBottomBorder={params.showBottomBorder}
          scrollbarWidth={verticalScrollbarWidth}
          gridHasFiller={hasFiller}
          {...rootProps.slotProps?.row}
        />
      ),
      renderInfiniteLoadingTrigger: (id) =>
        (apiRef as any).current.getInfiniteLoadingTriggerElement?.({ lastRowId: id }),
    },
  });

  // HACK: Keep the grid's store in sync with the virtualizer store. We set up the
  // subscription in the render phase rather than in an effect because other grid
  // initialization code runs between those two moments.
  //
  // TODO(v9): Remove this
  const disposeRef = React.useRef<Function>(null);
  useFirstRender(() => {
    apiRef.current.store.set('virtualization', virtualizer.store.state.virtualization);

    disposeRef.current = virtualizer.store.subscribe((state) => {
      if (state.virtualization !== apiRef.current.state.virtualization) {
        apiRef.current.setState((gridState) => ({
          ...gridState,
          virtualization: state.virtualization,
        }));
      }
    });
  });
  // XXX: We don't cleanup because there are async issues with the autosizing promise
  // code in testing. This could cause a memory leak.
  // useOnMount(() => () => { disposeRef.current?.(); });

  /*
   * API METHODS
   */

  const setVirtualization = (enabled: boolean) => {
    enabled &&= HAS_LAYOUT;
    virtualizer.store.set('virtualization', {
      ...virtualizer.store.state.virtualization,
      enabled,
      enabledForColumns: enabled,
      enabledForRows: enabled && !autoHeight,
    });
  };

  const setColumnVirtualization = (enabled: boolean) => {
    enabled &&= HAS_LAYOUT;
    virtualizer.store.set('virtualization', {
      ...virtualizer.store.state.virtualization,
      enabledForColumns: enabled,
    });
  };

  const api = {
    virtualScroller: virtualizer,
    unstable_setVirtualization: setVirtualization,
    unstable_setColumnVirtualization: setColumnVirtualization,
  };

  useGridApiMethod(apiRef, api, 'public');

  const forceUpdateRenderContext = virtualizer.virtualization.forceUpdateRenderContext;

  apiRef.current.register('private', {
    updateRenderContext: forceUpdateRenderContext,
  });

  /*
   * EFFECTS
   */

  useGridEventPriority(apiRef, 'sortedRowsSet', forceUpdateRenderContext);
  useGridEventPriority(apiRef, 'paginationModelChange', forceUpdateRenderContext);
  useGridEventPriority(apiRef, 'columnsChange', forceUpdateRenderContext);

  /* eslint-disable react-hooks/exhaustive-deps */
  React.useEffect(() => {
    setVirtualization(!rootProps.disableVirtualization);
  }, [disableVirtualization, autoHeight]);
  /* eslint-enable react-hooks/exhaustive-deps */
}

function needsHorizontalScrollbarSelector(apiRef: RefObject<GridApiCommunity>) {
  return (
    apiRef.current.state.dimensions.viewportOuterSize.width > 0 &&
    apiRef.current.state.dimensions.columnsTotalWidth >
      apiRef.current.state.dimensions.viewportOuterSize.width
  );
}

type RenderContextInputs = {
  enabledForRows: boolean;
  enabledForColumns: boolean;
  apiRef: RefObject<GridPrivateApiCommunity>;
  autoHeight: boolean;
  rowBufferPx: number;
  columnBufferPx: number;
  leftPinnedWidth: number;
  columnsTotalWidth: number;
  viewportInnerWidth: number;
  viewportInnerHeight: number;
  lastRowHeight: number;
  lastColumnWidth: number;
  rowsMeta: ReturnType<typeof gridRowsMetaSelector>;
  columnPositions: ReturnType<typeof gridColumnPositionsSelector>;
  rows: ReturnType<typeof useGridVisibleRows>['rows'];
  range: ReturnType<typeof useGridVisibleRows>['range'];
  pinnedColumns: ReturnType<typeof gridVisiblePinnedColumnDefinitionsSelector>;
  columns: ReturnType<typeof gridVisibleColumnDefinitionsSelector>;
  hiddenCellsOriginMap: ReturnType<typeof gridRowSpanningHiddenCellsOriginMapSelector>;
  listView: boolean;
  virtualizeColumnsWithAutoRowHeight: DataGridProcessedProps['virtualizeColumnsWithAutoRowHeight'];
};

function inputsSelector(
  apiRef: RefObject<GridPrivateApiCommunity>,
  rootProps: ReturnType<typeof useGridRootProps>,
  enabledForRows: boolean,
  enabledForColumns: boolean,
): RenderContextInputs {
  const dimensions = gridDimensionsSelector(apiRef);
  const currentPage = getVisibleRows(apiRef, rootProps);
  const columns = rootProps.listView
    ? [gridListColumnSelector(apiRef)!]
    : gridVisibleColumnDefinitionsSelector(apiRef);
  const hiddenCellsOriginMap = gridRowSpanningHiddenCellsOriginMapSelector(apiRef);
  const lastRowId = apiRef.current.state.rows.dataRowIds.at(-1);
  const lastColumn = columns.at(-1);
  return {
    enabledForRows,
    enabledForColumns,
    apiRef,
    autoHeight: rootProps.autoHeight,
    rowBufferPx: rootProps.rowBufferPx,
    columnBufferPx: rootProps.columnBufferPx,
    leftPinnedWidth: dimensions.leftPinnedWidth,
    columnsTotalWidth: dimensions.columnsTotalWidth,
    viewportInnerWidth: dimensions.viewportInnerSize.width,
    viewportInnerHeight: dimensions.viewportInnerSize.height,
    lastRowHeight: lastRowId !== undefined ? apiRef.current.unstable_getRowHeight(lastRowId) : 0,
    lastColumnWidth: lastColumn?.computedWidth ?? 0,
    rowsMeta: gridRowsMetaSelector(apiRef),
    columnPositions: gridColumnPositionsSelector(apiRef),
    rows: currentPage.rows,
    range: currentPage.range,
    pinnedColumns: gridVisiblePinnedColumnDefinitionsSelector(apiRef),
    columns,
    hiddenCellsOriginMap,
    listView: rootProps.listView ?? false,
    virtualizeColumnsWithAutoRowHeight: rootProps.virtualizeColumnsWithAutoRowHeight,
  };
}
