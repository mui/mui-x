import { GridRowId, GridRowModel, GridTreeNode } from '../../../models/gridRows';
import {
  createRootSelector,
  createSelector,
  createSelectorMemoized,
} from '../../../utils/createSelector';
import { GridStateCommunity } from '../../../models/gridStateCommunity';
import { GRID_ROOT_GROUP_ID } from './gridRowsUtils';

export const gridRowsStateSelector = createRootSelector((state: GridStateCommunity) => state.rows);

export const gridRowCountSelector = createSelector(
  gridRowsStateSelector,
  (rows) => rows.totalRowCount,
);

export const gridRowsLoadingSelector = createSelector(
  gridRowsStateSelector,
  (rows) => rows.loading,
);

export const gridTopLevelRowCountSelector = createSelector(
  gridRowsStateSelector,
  (rows) => rows.totalTopLevelRowCount,
);

// TODO rows v6: Rename
export const gridRowsLookupSelector = createSelector(
  gridRowsStateSelector,
  (rows) => rows.dataRowIdToModelLookup,
);

/**
 * @category Rows
 */
export const gridRowSelector = createSelector(
  gridRowsLookupSelector,
  (rows, id: GridRowId) => rows[id],
);

export const gridRowTreeSelector = createSelector(gridRowsStateSelector, (rows) => rows.tree);

/**
 * @category Rows
 */
export const gridRowNodeSelector = createSelector(
  gridRowTreeSelector,
  (rowTree, rowId: GridRowId) => rowTree[rowId],
);

export const gridRowGroupsToFetchSelector = createSelector(
  gridRowsStateSelector,
  (rows) => rows.groupsToFetch,
);

export const gridRowGroupingNameSelector = createSelector(
  gridRowsStateSelector,
  (rows) => rows.groupingName,
);

export const gridRowTreeDepthsSelector = createSelector(
  gridRowsStateSelector,
  (rows) => rows.treeDepths,
);

export const gridRowMaximumTreeDepthSelector = createSelectorMemoized(
  gridRowsStateSelector,
  (rows) => {
    const entries = Object.entries(rows.treeDepths);

    if (entries.length === 0) {
      return 1;
    }

    return (
      (entries
        .filter(([, nodeCount]) => nodeCount > 0)
        .map(([depth]) => Number(depth))
        .sort((a, b) => b - a)[0] ?? 0) + 1
    );
  },
);

/**
 * @category Rows
 */
export const gridDataRowIdsSelector = createSelector(
  gridRowsStateSelector,
  (rows) => rows.dataRowIds,
);

export const gridDataRowsSelector = createSelectorMemoized(
  gridDataRowIdsSelector,
  gridRowsLookupSelector,
  (dataRowIds, rowsLookup) =>
    dataRowIds.reduce((acc, id) => {
      if (!rowsLookup[id]) {
        return acc;
      }
      acc.push(rowsLookup[id]);
      return acc;
    }, [] as GridRowModel[]),
);

/**
 * @ignore - do not document.
 */
export const gridAdditionalRowGroupsSelector = createSelector(
  gridRowsStateSelector,
  (rows) => rows?.additionalRowGroups,
);

/**
 * @ignore - do not document.
 */
export const gridPinnedRowsSelector = createSelectorMemoized(
  gridAdditionalRowGroupsSelector,
  (additionalRowGroups) => {
    const rawPinnedRows = additionalRowGroups?.pinnedRows;

    return {
      bottom:
        rawPinnedRows?.bottom?.map((rowEntry) => ({
          id: rowEntry.id,
          model: rowEntry.model ?? {},
        })) ?? [],
      top:
        rawPinnedRows?.top?.map((rowEntry) => ({
          id: rowEntry.id,
          model: rowEntry.model ?? {},
        })) ?? [],
    };
  },
);

export const gridOrderedDataRowsSelector = createSelector(
  gridRowTreeSelector,
  gridRowsLookupSelector,
  (tree, rowsLookup) => {
    const orderedRows: GridRowModel[] = [];
    const rootNode = tree[GRID_ROOT_GROUP_ID];

    const traverse = (node: GridTreeNode) => {
      if (node.type === 'leaf') {
        orderedRows.push(rowsLookup[node.id]);
        return;
      }
      if (node.type === 'group') {
        if (!node.isAutoGenerated) {
          orderedRows.push(rowsLookup[node.id]);
        }
        node.children.forEach((childId) => {
          traverse(tree[childId]);
        });
      }
    };
    traverse(rootNode);
    return orderedRows;
  },
);

/**
 * @ignore - do not document.
 */
export const gridPinnedRowsCountSelector = createSelector(gridPinnedRowsSelector, (pinnedRows) => {
  return (pinnedRows?.top?.length || 0) + (pinnedRows?.bottom?.length || 0);
});
