"use strict";
'use client';
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useGridRows = exports.rowsStateInitializer = void 0;
var React = require("react");
var useLazyRef_1 = require("@mui/utils/useLazyRef");
var isObjectEmpty_1 = require("@mui/x-internals/isObjectEmpty");
var useGridApiMethod_1 = require("../../utils/useGridApiMethod");
var useGridLogger_1 = require("../../utils/useGridLogger");
var gridRowsSelector_1 = require("./gridRowsSelector");
var gridPropsSelectors_1 = require("../../core/gridPropsSelectors");
var useTimeout_1 = require("../../utils/useTimeout");
var signature_1 = require("../../../constants/signature");
var useGridEvent_1 = require("../../utils/useGridEvent");
var useGridVisibleRows_1 = require("../../utils/useGridVisibleRows");
var gridSortingSelector_1 = require("../sorting/gridSortingSelector");
var gridFilterSelector_1 = require("../filter/gridFilterSelector");
var gridRowsUtils_1 = require("./gridRowsUtils");
var pipeProcessing_1 = require("../../core/pipeProcessing");
var strategyProcessing_1 = require("../../core/strategyProcessing");
var pivoting_1 = require("../pivoting");
var rowsStateInitializer = function (state, props, apiRef) {
    var isDataSourceAvailable = !!props.dataSource;
    apiRef.current.caches.rows = (0, gridRowsUtils_1.createRowsInternalCache)({
        rows: isDataSourceAvailable ? [] : props.rows,
        getRowId: props.getRowId,
        loading: props.loading,
        rowCount: props.rowCount,
    });
    return __assign(__assign({}, state), { rows: (0, gridRowsUtils_1.getRowsStateFromCache)({
            apiRef: apiRef,
            rowCountProp: props.rowCount,
            loadingProp: isDataSourceAvailable ? true : props.loading,
            previousTree: null,
            previousTreeDepths: null,
        }) });
};
exports.rowsStateInitializer = rowsStateInitializer;
var useGridRows = function (apiRef, props) {
    if (process.env.NODE_ENV !== 'production') {
        try {
            // Freeze the `rows` prop so developers have a fast failure if they try to use Array.prototype.push().
            Object.freeze(props.rows);
        }
        catch (error) {
            // Sometimes, it's impossible to freeze, so we give up on it.
        }
    }
    var logger = (0, useGridLogger_1.useGridLogger)(apiRef, 'useGridRows');
    var lastUpdateMs = React.useRef(Date.now());
    var lastRowCount = React.useRef(props.rowCount);
    var timeout = (0, useTimeout_1.useTimeout)();
    var getRow = React.useCallback(function (id) {
        var _a;
        var model = (0, gridRowsSelector_1.gridRowsLookupSelector)(apiRef)[id];
        if (model) {
            return model;
        }
        var node = (0, gridRowsSelector_1.gridRowNodeSelector)(apiRef, id);
        if (node && (0, gridRowsUtils_1.isAutogeneratedRowNode)(node)) {
            return _a = {}, _a[gridRowsUtils_1.GRID_ID_AUTOGENERATED] = id, _a;
        }
        return null;
    }, [apiRef]);
    var getRowId = React.useCallback(function (row) { return (0, gridPropsSelectors_1.gridRowIdSelector)(apiRef, row); }, [apiRef]);
    var throttledRowsChange = React.useCallback(function (_a) {
        var cache = _a.cache, throttle = _a.throttle;
        var run = function () {
            lastUpdateMs.current = Date.now();
            apiRef.current.setState(function (state) { return (__assign(__assign({}, state), { rows: (0, gridRowsUtils_1.getRowsStateFromCache)({
                    apiRef: apiRef,
                    rowCountProp: props.rowCount,
                    loadingProp: props.loading,
                    previousTree: (0, gridRowsSelector_1.gridRowTreeSelector)(apiRef),
                    previousTreeDepths: (0, gridRowsSelector_1.gridRowTreeDepthsSelector)(apiRef),
                    previousGroupsToFetch: (0, gridRowsSelector_1.gridRowGroupsToFetchSelector)(apiRef),
                }) })); });
            apiRef.current.publishEvent('rowsSet');
        };
        timeout.clear();
        apiRef.current.caches.rows = cache;
        if (!throttle) {
            run();
            return;
        }
        var throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);
        if (throttleRemainingTimeMs > 0) {
            timeout.start(throttleRemainingTimeMs, run);
            return;
        }
        run();
    }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef, timeout]);
    /**
     * API METHODS
     */
    var setRows = React.useCallback(function (rows) {
        logger.debug("Updating all rows, new length ".concat(rows.length));
        if ((0, pivoting_1.gridPivotActiveSelector)(apiRef)) {
            apiRef.current.updateNonPivotRows(rows, false);
            return;
        }
        var cache = (0, gridRowsUtils_1.createRowsInternalCache)({
            rows: rows,
            getRowId: props.getRowId,
            loading: props.loading,
            rowCount: props.rowCount,
        });
        var prevCache = apiRef.current.caches.rows;
        cache.rowsBeforePartialUpdates = prevCache.rowsBeforePartialUpdates;
        throttledRowsChange({ cache: cache, throttle: true });
    }, [logger, props.getRowId, props.loading, props.rowCount, throttledRowsChange, apiRef]);
    var updateRows = React.useCallback(function (updates) {
        if (props.signature === signature_1.GridSignature.DataGrid && updates.length > 1) {
            throw new Error([
                'MUI X: You cannot update several rows at once in `apiRef.current.updateRows` on the DataGrid.',
                'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.',
            ].join('\n'));
        }
        if ((0, pivoting_1.gridPivotActiveSelector)(apiRef)) {
            apiRef.current.updateNonPivotRows(updates);
            return;
        }
        var nonPinnedRowsUpdates = (0, gridRowsUtils_1.computeRowsUpdates)(apiRef, updates, props.getRowId);
        var cache = (0, gridRowsUtils_1.updateCacheWithNewRows)({
            updates: nonPinnedRowsUpdates,
            getRowId: props.getRowId,
            previousCache: apiRef.current.caches.rows,
        });
        throttledRowsChange({ cache: cache, throttle: true });
    }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);
    var updateNestedRows = React.useCallback(function (updates, groupKeys) {
        var nonPinnedRowsUpdates = (0, gridRowsUtils_1.computeRowsUpdates)(apiRef, updates, props.getRowId);
        var cache = (0, gridRowsUtils_1.updateCacheWithNewRows)({
            updates: nonPinnedRowsUpdates,
            getRowId: props.getRowId,
            previousCache: apiRef.current.caches.rows,
            groupKeys: groupKeys !== null && groupKeys !== void 0 ? groupKeys : [],
        });
        throttledRowsChange({ cache: cache, throttle: false });
    }, [props.getRowId, throttledRowsChange, apiRef]);
    var setLoading = React.useCallback(function (loading) {
        logger.debug("Setting loading to ".concat(loading));
        apiRef.current.setState(function (state) { return (__assign(__assign({}, state), { rows: __assign(__assign({}, state.rows), { loading: loading }) })); });
        apiRef.current.caches.rows.loadingPropBeforePartialUpdates = loading;
    }, [apiRef, logger]);
    var getRowModels = React.useCallback(function () {
        var dataRows = (0, gridRowsSelector_1.gridDataRowIdsSelector)(apiRef);
        var idRowsLookup = (0, gridRowsSelector_1.gridRowsLookupSelector)(apiRef);
        return new Map(dataRows.map(function (id) { var _a; return [id, (_a = idRowsLookup[id]) !== null && _a !== void 0 ? _a : {}]; }));
    }, [apiRef]);
    var getRowsCount = React.useCallback(function () { return (0, gridRowsSelector_1.gridRowCountSelector)(apiRef); }, [apiRef]);
    var getAllRowIds = React.useCallback(function () { return (0, gridRowsSelector_1.gridDataRowIdsSelector)(apiRef); }, [apiRef]);
    var getRowIndexRelativeToVisibleRows = React.useCallback(function (id) {
        var rowIdToIndexMap = (0, useGridVisibleRows_1.getVisibleRows)(apiRef).rowIdToIndexMap;
        return rowIdToIndexMap.get(id);
    }, [apiRef]);
    var setRowChildrenExpansion = React.useCallback(function (id, isExpanded) {
        var currentNode = (0, gridRowsSelector_1.gridRowNodeSelector)(apiRef, id);
        if (!currentNode) {
            throw new Error("MUI X: No row with id #".concat(id, " found."));
        }
        if (currentNode.type !== 'group') {
            throw new Error('MUI X: Only group nodes can be expanded or collapsed.');
        }
        var newNode = __assign(__assign({}, currentNode), { childrenExpanded: isExpanded });
        apiRef.current.setState(function (state) {
            var _a;
            return __assign(__assign({}, state), { rows: __assign(__assign({}, state.rows), { tree: __assign(__assign({}, state.rows.tree), (_a = {}, _a[id] = newNode, _a)) }) });
        });
        apiRef.current.publishEvent('rowExpansionChange', newNode);
    }, [apiRef]);
    var getRowNode = React.useCallback(function (id) { var _a; return (_a = (0, gridRowsSelector_1.gridRowNodeSelector)(apiRef, id)) !== null && _a !== void 0 ? _a : null; }, [apiRef]);
    var getRowGroupChildren = React.useCallback(function (_a) {
        var _b = _a.skipAutoGeneratedRows, skipAutoGeneratedRows = _b === void 0 ? true : _b, groupId = _a.groupId, applySorting = _a.applySorting, applyFiltering = _a.applyFiltering, _c = _a.directChildrenOnly, directChildrenOnly = _c === void 0 ? false : _c;
        var tree = (0, gridRowsSelector_1.gridRowTreeSelector)(apiRef);
        var children;
        if (applySorting) {
            var groupNode = tree[groupId];
            if (!groupNode) {
                return [];
            }
            var sortedRowIds = (0, gridSortingSelector_1.gridSortedRowIdsSelector)(apiRef);
            children = [];
            var startIndex = sortedRowIds.findIndex(function (id) { return id === groupId; }) + 1;
            for (var index = startIndex; index < sortedRowIds.length &&
                (directChildrenOnly
                    ? tree[sortedRowIds[index]].depth === groupNode.depth + 1
                    : tree[sortedRowIds[index]].depth > groupNode.depth); index += 1) {
                var id = sortedRowIds[index];
                if (!skipAutoGeneratedRows || !(0, gridRowsUtils_1.isAutogeneratedRowNode)(tree[id])) {
                    children.push(id);
                }
            }
        }
        else {
            children = (0, gridRowsUtils_1.getTreeNodeDescendants)(tree, groupId, skipAutoGeneratedRows, directChildrenOnly);
        }
        if (applyFiltering) {
            var filteredRowsLookup_1 = (0, gridFilterSelector_1.gridFilteredRowsLookupSelector)(apiRef);
            children = (0, isObjectEmpty_1.isObjectEmpty)(filteredRowsLookup_1)
                ? children
                : children.filter(function (childId) { return filteredRowsLookup_1[childId] !== false; });
        }
        return children;
    }, [apiRef]);
    var setRowIndex = React.useCallback(function (rowId, targetIndex) {
        var node = (0, gridRowsSelector_1.gridRowNodeSelector)(apiRef, rowId);
        if (!node) {
            throw new Error("MUI X: No row with id #".concat(rowId, " found."));
        }
        if (node.parent !== gridRowsUtils_1.GRID_ROOT_GROUP_ID) {
            throw new Error("MUI X: The row reordering do not support reordering of grouped rows yet.");
        }
        if (node.type !== 'leaf') {
            throw new Error("MUI X: The row reordering do not support reordering of footer or grouping rows.");
        }
        apiRef.current.setState(function (state) {
            var _a;
            var group = (0, gridRowsSelector_1.gridRowTreeSelector)(apiRef)[gridRowsUtils_1.GRID_ROOT_GROUP_ID];
            var allRows = group.children;
            var oldIndex = allRows.findIndex(function (row) { return row === rowId; });
            if (oldIndex === -1 || oldIndex === targetIndex) {
                return state;
            }
            logger.debug("Moving row ".concat(rowId, " to index ").concat(targetIndex));
            var updatedRows = __spreadArray([], allRows, true);
            updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);
            return __assign(__assign({}, state), { rows: __assign(__assign({}, state.rows), { tree: __assign(__assign({}, state.rows.tree), (_a = {}, _a[gridRowsUtils_1.GRID_ROOT_GROUP_ID] = __assign(__assign({}, group), { children: updatedRows }), _a)) }) });
        });
        apiRef.current.publishEvent('rowsSet');
    }, [apiRef, logger]);
    var replaceRows = React.useCallback(function (firstRowToRender, newRows) {
        if (props.signature === signature_1.GridSignature.DataGrid && newRows.length > 1) {
            throw new Error([
                'MUI X: You cannot replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.',
                'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.',
            ].join('\n'));
        }
        if (newRows.length === 0) {
            return;
        }
        var treeDepth = (0, gridRowsSelector_1.gridRowMaximumTreeDepthSelector)(apiRef);
        if (treeDepth > 1) {
            throw new Error('`apiRef.current.unstable_replaceRows` is not compatible with tree data and row grouping');
        }
        var tree = __assign({}, (0, gridRowsSelector_1.gridRowTreeSelector)(apiRef));
        var dataRowIdToModelLookup = __assign({}, (0, gridRowsSelector_1.gridRowsLookupSelector)(apiRef));
        var rootGroup = tree[gridRowsUtils_1.GRID_ROOT_GROUP_ID];
        var rootGroupChildren = __spreadArray([], rootGroup.children, true);
        var seenIds = new Set();
        for (var i = 0; i < newRows.length; i += 1) {
            var rowModel = newRows[i];
            var rowId = (0, gridRowsUtils_1.getRowIdFromRowModel)(rowModel, props.getRowId, 'A row was provided without id when calling replaceRows().');
            var removedRowId = rootGroupChildren.splice(firstRowToRender + i, 1, rowId)[0];
            if (!seenIds.has(removedRowId)) {
                delete dataRowIdToModelLookup[removedRowId];
                delete tree[removedRowId];
            }
            var rowTreeNodeConfig = {
                id: rowId,
                depth: 0,
                parent: gridRowsUtils_1.GRID_ROOT_GROUP_ID,
                type: 'leaf',
                groupingKey: null,
            };
            dataRowIdToModelLookup[rowId] = rowModel;
            tree[rowId] = rowTreeNodeConfig;
            seenIds.add(rowId);
        }
        tree[gridRowsUtils_1.GRID_ROOT_GROUP_ID] = __assign(__assign({}, rootGroup), { children: rootGroupChildren });
        // Removes potential remaining skeleton rows from the dataRowIds.
        var dataRowIds = rootGroupChildren.filter(function (childId) { var _a; return ((_a = tree[childId]) === null || _a === void 0 ? void 0 : _a.type) === 'leaf'; });
        apiRef.current.caches.rows.dataRowIdToModelLookup = dataRowIdToModelLookup;
        apiRef.current.setState(function (state) { return (__assign(__assign({}, state), { rows: __assign(__assign({}, state.rows), { loading: props.loading, totalRowCount: Math.max(props.rowCount || 0, rootGroupChildren.length), dataRowIdToModelLookup: dataRowIdToModelLookup, dataRowIds: dataRowIds, tree: tree }) })); });
        apiRef.current.publishEvent('rowsSet');
    }, [apiRef, props.signature, props.getRowId, props.loading, props.rowCount]);
    var rowApi = {
        getRow: getRow,
        setLoading: setLoading,
        getRowId: getRowId,
        getRowModels: getRowModels,
        getRowsCount: getRowsCount,
        getAllRowIds: getAllRowIds,
        setRows: setRows,
        updateRows: updateRows,
        getRowNode: getRowNode,
        getRowIndexRelativeToVisibleRows: getRowIndexRelativeToVisibleRows,
        unstable_replaceRows: replaceRows,
    };
    var rowProApi = {
        setRowIndex: setRowIndex,
        setRowChildrenExpansion: setRowChildrenExpansion,
        getRowGroupChildren: getRowGroupChildren,
    };
    var rowProPrivateApi = {
        updateNestedRows: updateNestedRows,
    };
    /**
     * EVENTS
     */
    var groupRows = React.useCallback(function () {
        logger.info("Row grouping pre-processing have changed, regenerating the row tree");
        var cache;
        if (apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows) {
            // The `props.rows` did not change since the last row grouping
            // We can use the current rows cache which contains the partial updates done recently.
            cache = __assign(__assign({}, apiRef.current.caches.rows), { updates: {
                    type: 'full',
                    rows: (0, gridRowsSelector_1.gridDataRowIdsSelector)(apiRef),
                } });
        }
        else {
            // The `props.rows` has changed since the last row grouping
            // We must use the new `props.rows` on the new grouping
            // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render
            cache = (0, gridRowsUtils_1.createRowsInternalCache)({
                rows: props.rows,
                getRowId: props.getRowId,
                loading: props.loading,
                rowCount: props.rowCount,
            });
        }
        throttledRowsChange({ cache: cache, throttle: false });
    }, [
        logger,
        apiRef,
        props.rows,
        props.getRowId,
        props.loading,
        props.rowCount,
        throttledRowsChange,
    ]);
    var previousDataSource = (0, useLazyRef_1.default)(function () { return props.dataSource; });
    var handleStrategyProcessorChange = React.useCallback(function (methodName) {
        if (props.dataSource && props.dataSource !== previousDataSource.current) {
            previousDataSource.current = props.dataSource;
            return;
        }
        if (methodName === 'rowTreeCreation') {
            groupRows();
        }
    }, [groupRows, previousDataSource, props.dataSource]);
    var handleStrategyActivityChange = React.useCallback(function () {
        // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.
        // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.
        if (apiRef.current.getActiveStrategy(strategyProcessing_1.GridStrategyGroup.RowTree) !==
            (0, gridRowsSelector_1.gridRowGroupingNameSelector)(apiRef)) {
            groupRows();
        }
    }, [apiRef, groupRows]);
    (0, useGridEvent_1.useGridEvent)(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);
    (0, useGridEvent_1.useGridEvent)(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);
    /**
     * APPLIERS
     */
    var applyHydrateRowsProcessor = React.useCallback(function () {
        apiRef.current.setState(function (state) {
            var response = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {
                tree: (0, gridRowsSelector_1.gridRowTreeSelector)(apiRef),
                treeDepths: (0, gridRowsSelector_1.gridRowTreeDepthsSelector)(apiRef),
                dataRowIds: (0, gridRowsSelector_1.gridDataRowIdsSelector)(apiRef),
                dataRowIdToModelLookup: (0, gridRowsSelector_1.gridRowsLookupSelector)(apiRef),
            });
            return __assign(__assign({}, state), { rows: __assign(__assign(__assign({}, state.rows), response), { totalTopLevelRowCount: (0, gridRowsUtils_1.getTopLevelRowCount)({
                        tree: response.tree,
                        rowCountProp: props.rowCount,
                    }) }) });
        });
        apiRef.current.publishEvent('rowsSet');
    }, [apiRef, props.rowCount]);
    (0, pipeProcessing_1.useGridRegisterPipeApplier)(apiRef, 'hydrateRows', applyHydrateRowsProcessor);
    (0, useGridApiMethod_1.useGridApiMethod)(apiRef, rowApi, 'public');
    (0, useGridApiMethod_1.useGridApiMethod)(apiRef, rowProApi, props.signature === signature_1.GridSignature.DataGrid ? 'private' : 'public');
    (0, useGridApiMethod_1.useGridApiMethod)(apiRef, rowProPrivateApi, 'private');
    // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`
    // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one
    var isFirstRender = React.useRef(true);
    React.useEffect(function () {
        if (isFirstRender.current) {
            isFirstRender.current = false;
            return;
        }
        var isRowCountPropUpdated = false;
        if (props.rowCount !== lastRowCount.current) {
            isRowCountPropUpdated = true;
            lastRowCount.current = props.rowCount;
        }
        var currentRows = props.dataSource ? (0, gridRowsSelector_1.gridDataRowsSelector)(apiRef) : props.rows;
        var areNewRowsAlreadyInState = apiRef.current.caches.rows.rowsBeforePartialUpdates === currentRows;
        var isNewLoadingAlreadyInState = apiRef.current.caches.rows.loadingPropBeforePartialUpdates === props.loading;
        var isNewRowCountAlreadyInState = apiRef.current.caches.rows.rowCountPropBeforePartialUpdates === props.rowCount;
        // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)
        if (areNewRowsAlreadyInState) {
            // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`
            if (!isNewLoadingAlreadyInState) {
                apiRef.current.setState(function (state) { return (__assign(__assign({}, state), { rows: __assign(__assign({}, state.rows), { loading: props.loading }) })); });
                apiRef.current.caches.rows.loadingPropBeforePartialUpdates = props.loading;
            }
            if (!isNewRowCountAlreadyInState) {
                apiRef.current.setState(function (state) { return (__assign(__assign({}, state), { rows: __assign(__assign({}, state.rows), { totalRowCount: Math.max(props.rowCount || 0, state.rows.totalRowCount), totalTopLevelRowCount: Math.max(props.rowCount || 0, state.rows.totalTopLevelRowCount) }) })); });
                apiRef.current.caches.rows.rowCountPropBeforePartialUpdates = props.rowCount;
            }
            if (!isRowCountPropUpdated) {
                return;
            }
        }
        logger.debug("Updating all rows, new length ".concat(currentRows === null || currentRows === void 0 ? void 0 : currentRows.length));
        throttledRowsChange({
            cache: (0, gridRowsUtils_1.createRowsInternalCache)({
                rows: currentRows,
                getRowId: props.getRowId,
                loading: props.loading,
                rowCount: props.rowCount,
            }),
            throttle: false,
        });
    }, [
        props.rows,
        props.rowCount,
        props.getRowId,
        props.loading,
        props.dataSource,
        logger,
        throttledRowsChange,
        apiRef,
    ]);
};
exports.useGridRows = useGridRows;
