"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRowHeightWarning = exports.rowHeightWarning = exports.getValidRowHeight = exports.minimalContentHeight = exports.updateCacheWithNewRows = exports.getTreeNodeDescendants = exports.isAutogeneratedRowNode = exports.isAutogeneratedRow = exports.getRowsStateFromCache = exports.getTopLevelRowCount = exports.createRowsInternalCache = exports.getRowValue = exports.getRowIdFromRowModel = exports.buildRootGroup = exports.GRID_ID_AUTOGENERATED = exports.GRID_ROOT_GROUP_ID = void 0;
exports.checkGridRowIdIsValid = checkGridRowIdIsValid;
exports.computeRowsUpdates = computeRowsUpdates;
var gridRowsSelector_1 = require("./gridRowsSelector");
exports.GRID_ROOT_GROUP_ID = "auto-generated-group-node-root";
exports.GRID_ID_AUTOGENERATED = Symbol('mui.id_autogenerated');
var buildRootGroup = function () { return ({
    type: 'group',
    id: exports.GRID_ROOT_GROUP_ID,
    depth: -1,
    groupingField: null,
    groupingKey: null,
    isAutoGenerated: true,
    children: [],
    childrenFromPath: {},
    childrenExpanded: true,
    parent: null,
}); };
exports.buildRootGroup = buildRootGroup;
/**
 * A helper function to check if the id provided is valid.
 * @param {GridRowId} id Id as [[GridRowId]].
 * @param {GridRowModel | Partial<GridRowModel>} row Row as [[GridRowModel]].
 * @param {string} detailErrorMessage A custom error message to display for invalid IDs
 */
function checkGridRowIdIsValid(id, row, detailErrorMessage) {
    if (detailErrorMessage === void 0) { detailErrorMessage = 'A row was provided without id in the rows prop:'; }
    if (id == null) {
        throw new Error([
            'MUI X: The Data Grid component requires all rows to have a unique `id` property.',
            'Alternatively, you can use the `getRowId` prop to specify a custom id for each row.',
            detailErrorMessage,
            JSON.stringify(row),
        ].join('\n'));
    }
}
var getRowIdFromRowModel = function (rowModel, getRowId, detailErrorMessage) {
    var id = getRowId ? getRowId(rowModel) : rowModel.id;
    checkGridRowIdIsValid(id, rowModel, detailErrorMessage);
    return id;
};
exports.getRowIdFromRowModel = getRowIdFromRowModel;
var getRowValue = function (row, colDef, apiRef) {
    var field = colDef.field;
    if (!colDef || !colDef.valueGetter) {
        return row[field];
    }
    var value = row[colDef.field];
    return colDef.valueGetter(value, row, colDef, apiRef);
};
exports.getRowValue = getRowValue;
var createRowsInternalCache = function (_a) {
    var rows = _a.rows, getRowId = _a.getRowId, loading = _a.loading, rowCount = _a.rowCount;
    var updates = {
        type: 'full',
        rows: [],
    };
    var dataRowIdToModelLookup = {};
    for (var i = 0; i < rows.length; i += 1) {
        var model = rows[i];
        var id = (0, exports.getRowIdFromRowModel)(model, getRowId);
        dataRowIdToModelLookup[id] = model;
        updates.rows.push(id);
    }
    return {
        rowsBeforePartialUpdates: rows,
        loadingPropBeforePartialUpdates: loading,
        rowCountPropBeforePartialUpdates: rowCount,
        updates: updates,
        dataRowIdToModelLookup: dataRowIdToModelLookup,
    };
};
exports.createRowsInternalCache = createRowsInternalCache;
var getTopLevelRowCount = function (_a) {
    var tree = _a.tree, _b = _a.rowCountProp, rowCountProp = _b === void 0 ? 0 : _b;
    var rootGroupNode = tree[exports.GRID_ROOT_GROUP_ID];
    return Math.max(rowCountProp, rootGroupNode.children.length + (rootGroupNode.footerId == null ? 0 : 1));
};
exports.getTopLevelRowCount = getTopLevelRowCount;
var getRowsStateFromCache = function (_a) {
    var apiRef = _a.apiRef, _b = _a.rowCountProp, rowCountProp = _b === void 0 ? 0 : _b, loadingProp = _a.loadingProp, previousTree = _a.previousTree, previousTreeDepths = _a.previousTreeDepths, previousGroupsToFetch = _a.previousGroupsToFetch;
    var cache = apiRef.current.caches.rows;
    // 1. Apply the "rowTreeCreation" family processing.
    var _c = apiRef.current.applyStrategyProcessor('rowTreeCreation', {
        previousTree: previousTree,
        previousTreeDepths: previousTreeDepths,
        updates: cache.updates,
        dataRowIdToModelLookup: cache.dataRowIdToModelLookup,
        previousGroupsToFetch: previousGroupsToFetch,
    }), unProcessedTree = _c.tree, unProcessedTreeDepths = _c.treeDepths, unProcessedDataRowIds = _c.dataRowIds, groupingName = _c.groupingName, _d = _c.groupsToFetch, groupsToFetch = _d === void 0 ? [] : _d;
    // 2. Apply the "hydrateRows" pipe-processing.
    var groupingParamsWithHydrateRows = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {
        tree: unProcessedTree,
        treeDepths: unProcessedTreeDepths,
        dataRowIds: unProcessedDataRowIds,
        dataRowIdToModelLookup: cache.dataRowIdToModelLookup,
    });
    // 3. Reset the cache updates
    apiRef.current.caches.rows.updates = {
        type: 'partial',
        actions: {
            insert: [],
            modify: [],
            remove: [],
        },
        idToActionLookup: {},
    };
    return __assign(__assign({}, groupingParamsWithHydrateRows), { totalRowCount: Math.max(rowCountProp, groupingParamsWithHydrateRows.dataRowIds.length), totalTopLevelRowCount: (0, exports.getTopLevelRowCount)({
            tree: groupingParamsWithHydrateRows.tree,
            rowCountProp: rowCountProp,
        }), groupingName: groupingName, loading: loadingProp, groupsToFetch: groupsToFetch });
};
exports.getRowsStateFromCache = getRowsStateFromCache;
var isAutogeneratedRow = function (row) { return exports.GRID_ID_AUTOGENERATED in row; };
exports.isAutogeneratedRow = isAutogeneratedRow;
var isAutogeneratedRowNode = function (rowNode) {
    return rowNode.type === 'skeletonRow' ||
        rowNode.type === 'footer' ||
        (rowNode.type === 'group' && rowNode.isAutoGenerated) ||
        (rowNode.type === 'pinnedRow' && rowNode.isAutoGenerated);
};
exports.isAutogeneratedRowNode = isAutogeneratedRowNode;
var getTreeNodeDescendants = function (tree, parentId, skipAutoGeneratedRows, directChildrenOnly) {
    var node = tree[parentId];
    if (node.type !== 'group') {
        return [];
    }
    var validDescendants = [];
    for (var i = 0; i < node.children.length; i += 1) {
        var child = node.children[i];
        if (!skipAutoGeneratedRows || !(0, exports.isAutogeneratedRowNode)(tree[child])) {
            validDescendants.push(child);
        }
        if (directChildrenOnly) {
            continue;
        }
        var childDescendants = (0, exports.getTreeNodeDescendants)(tree, child, skipAutoGeneratedRows, directChildrenOnly);
        for (var j = 0; j < childDescendants.length; j += 1) {
            validDescendants.push(childDescendants[j]);
        }
    }
    if (!skipAutoGeneratedRows && node.footerId != null) {
        validDescendants.push(node.footerId);
    }
    return validDescendants;
};
exports.getTreeNodeDescendants = getTreeNodeDescendants;
var updateCacheWithNewRows = function (_a) {
    var _b, _c, _d;
    var previousCache = _a.previousCache, getRowId = _a.getRowId, updates = _a.updates, groupKeys = _a.groupKeys;
    if (previousCache.updates.type === 'full') {
        throw new Error('MUI X: Unable to prepare a partial update if a full update is not applied yet.');
    }
    // Remove duplicate updates.
    // A server can batch updates, and send several updates for the same row in one fn call.
    var uniqueUpdates = new Map();
    updates.forEach(function (update) {
        var id = (0, exports.getRowIdFromRowModel)(update, getRowId, 'A row was provided without id when calling updateRows():');
        if (uniqueUpdates.has(id)) {
            uniqueUpdates.set(id, __assign(__assign({}, uniqueUpdates.get(id)), update));
        }
        else {
            uniqueUpdates.set(id, update);
        }
    });
    var partialUpdates = {
        type: 'partial',
        actions: {
            insert: __spreadArray([], ((_b = previousCache.updates.actions.insert) !== null && _b !== void 0 ? _b : []), true),
            modify: __spreadArray([], ((_c = previousCache.updates.actions.modify) !== null && _c !== void 0 ? _c : []), true),
            remove: __spreadArray([], ((_d = previousCache.updates.actions.remove) !== null && _d !== void 0 ? _d : []), true),
        },
        idToActionLookup: __assign({}, previousCache.updates.idToActionLookup),
        groupKeys: groupKeys,
    };
    var dataRowIdToModelLookup = __assign({}, previousCache.dataRowIdToModelLookup);
    var alreadyAppliedActionsToRemove = { insert: {}, modify: {}, remove: {} };
    // Depending on the action already applied to the data row,
    // We might want drop the already-applied-update.
    // For instance:
    // - if you delete then insert, then you don't want to apply the deletion in the tree.
    // - if you insert, then modify, then you just want to apply the insertion in the tree.
    uniqueUpdates.forEach(function (partialRow, id) {
        var actionAlreadyAppliedToRow = partialUpdates.idToActionLookup[id];
        // Action === "delete"
        // eslint-disable-next-line no-underscore-dangle
        if (partialRow._action === 'delete') {
            // If the data row has been removed since the last state update,
            // Then do nothing.
            if (actionAlreadyAppliedToRow === 'remove' || !dataRowIdToModelLookup[id]) {
                return;
            }
            // If the data row has been inserted / modified since the last state update,
            // Then drop this "insert" / "modify" update.
            if (actionAlreadyAppliedToRow != null) {
                alreadyAppliedActionsToRemove[actionAlreadyAppliedToRow][id] = true;
            }
            // Remove the data row from the lookups and add it to the "delete" update.
            partialUpdates.actions.remove.push(id);
            delete dataRowIdToModelLookup[id];
            return;
        }
        var oldRow = dataRowIdToModelLookup[id];
        // Action === "modify"
        if (oldRow) {
            // If the data row has been removed since the last state update,
            // Then drop this "remove" update and add it to the "modify" update instead.
            if (actionAlreadyAppliedToRow === 'remove') {
                alreadyAppliedActionsToRemove.remove[id] = true;
                partialUpdates.actions.modify.push(id);
            }
            // If the date has not been inserted / modified since the last state update,
            // Then add it to the "modify" update (if it has been inserted it should just remain "inserted").
            else if (actionAlreadyAppliedToRow == null) {
                partialUpdates.actions.modify.push(id);
            }
            // Update the data row lookups.
            dataRowIdToModelLookup[id] = __assign(__assign({}, oldRow), partialRow);
            return;
        }
        // Action === "insert"
        // If the data row has been removed since the last state update,
        // Then drop the "remove" update and add it to the "insert" update instead.
        if (actionAlreadyAppliedToRow === 'remove') {
            alreadyAppliedActionsToRemove.remove[id] = true;
            partialUpdates.actions.insert.push(id);
        }
        // If the data row has not been inserted since the last state update,
        // Then add it to the "insert" update.
        // `actionAlreadyAppliedToRow` can't be equal to "modify", otherwise we would have an `oldRow` above.
        else if (actionAlreadyAppliedToRow == null) {
            partialUpdates.actions.insert.push(id);
        }
        // Update the data row lookups.
        dataRowIdToModelLookup[id] = partialRow;
    });
    var actionTypeWithActionsToRemove = Object.keys(alreadyAppliedActionsToRemove);
    var _loop_1 = function (i) {
        var actionType = actionTypeWithActionsToRemove[i];
        var idsToRemove = alreadyAppliedActionsToRemove[actionType];
        if (Object.keys(idsToRemove).length > 0) {
            partialUpdates.actions[actionType] = partialUpdates.actions[actionType].filter(function (id) { return !idsToRemove[id]; });
        }
    };
    for (var i = 0; i < actionTypeWithActionsToRemove.length; i += 1) {
        _loop_1(i);
    }
    return {
        dataRowIdToModelLookup: dataRowIdToModelLookup,
        updates: partialUpdates,
        rowsBeforePartialUpdates: previousCache.rowsBeforePartialUpdates,
        loadingPropBeforePartialUpdates: previousCache.loadingPropBeforePartialUpdates,
        rowCountPropBeforePartialUpdates: previousCache.rowCountPropBeforePartialUpdates,
    };
};
exports.updateCacheWithNewRows = updateCacheWithNewRows;
exports.minimalContentHeight = 'var(--DataGrid-overlayHeight, calc(var(--height) * 2))';
function computeRowsUpdates(apiRef, updates, getRowId) {
    var nonPinnedRowsUpdates = [];
    updates.forEach(function (update) {
        var id = (0, exports.getRowIdFromRowModel)(update, getRowId, 'A row was provided without id when calling updateRows():');
        var rowNode = (0, gridRowsSelector_1.gridRowNodeSelector)(apiRef, id);
        if ((rowNode === null || rowNode === void 0 ? void 0 : rowNode.type) === 'pinnedRow') {
            // @ts-ignore because otherwise `release:build` doesn't work
            var pinnedRowsCache = apiRef.current.caches.pinnedRows;
            var prevModel = pinnedRowsCache.idLookup[id];
            if (prevModel) {
                pinnedRowsCache.idLookup[id] = __assign(__assign({}, prevModel), update);
            }
        }
        else {
            nonPinnedRowsUpdates.push(update);
        }
    });
    return nonPinnedRowsUpdates;
}
var warnedOnceInvalidRowHeight = false;
var getValidRowHeight = function (rowHeightProp, defaultRowHeight, warningMessage) {
    if (typeof rowHeightProp === 'number' && rowHeightProp > 0) {
        return rowHeightProp;
    }
    if (process.env.NODE_ENV !== 'production' &&
        !warnedOnceInvalidRowHeight &&
        typeof rowHeightProp !== 'undefined' &&
        rowHeightProp !== null) {
        console.warn(warningMessage);
        warnedOnceInvalidRowHeight = true;
    }
    return defaultRowHeight;
};
exports.getValidRowHeight = getValidRowHeight;
exports.rowHeightWarning = [
    "MUI X: The `rowHeight` prop should be a number greater than 0.",
    "The default value will be used instead.",
].join('\n');
exports.getRowHeightWarning = [
    "MUI X: The `getRowHeight` prop should return a number greater than 0 or 'auto'.",
    "The default value will be used instead.",
].join('\n');
