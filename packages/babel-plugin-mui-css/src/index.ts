import * as vm from 'node:vm';
import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { dirname, basename, resolve as resolvePath } from 'node:path';
import { transform as minifyCSS } from 'lightningcss';
import { packageDirectorySync } from 'pkg-dir';
import * as Babel from '@babel/core';
import * as ts from 'typescript';
import { stylesToString } from './css/stylesToString.js';

type BabelT = typeof Babel;

const PLUGIN_NAME = 'mui-css';
const CONFIG_FILENAME = 'mui-css.config.json';

type State = {
  enabled: boolean;
  options: any;
  config: ProjectConfig;
  rules: { content: string }[];
};

type ProjectConfig = {
  configPath: string;
  data: any;
  variablesCode: string | undefined;
};

const configsByPath = new Map<string, ProjectConfig | null>();

export default function transformCSS({ types: t }: BabelT) {
  return {
    name: PLUGIN_NAME,

    pre(file) {
      const options = findSelf(file.opts.plugins).options;
      const config = getConfig(file.opts.filename);
      file.metadata.muiCSS = {
        enabled: config !== null && !file.opts.filename.includes('cssVariables'),
        options,
        config,
        rules: [],
      } as State;
    },

    post(file) {
      const state = file.metadata.muiCSS as State;
      if (!state.enabled) {
        return;
      }
      if (state.rules.length === 0) {
        return;
      }
    },

    visitor: {
      Program: {
        exit(path, { file }) {
          const state = file.metadata.muiCSS as State;
          if (!state.enabled) {
            return;
          }
          if (state.rules.length === 0) {
            return;
          }

          let cssContent = '';
          cssContent = state.rules.map((r) => r.content).join('\n');
          if (state.config.data.cssMinify ?? true) {
            const { code: cssMinified } = minifyCSS({
              filename: 'index.css',
              code: Buffer.from(cssContent),
              minify: true,
            });
            cssContent = cssMinified as any;
          }

          const filePath = file.opts.filename;
          const cssFilename = `${basename(filePath).split('.').slice(0, -1).join('.')}.autogenerated.css`;
          const outputPath = resolvePath(dirname(filePath), cssFilename);
          writeFileSync(outputPath, cssContent);

          path.node.body.unshift(t.importDeclaration([], t.stringLiteral(`./${cssFilename}`)));
        },
      },

      // const styles = css('prefix', {
      //   class1: { ... },
      // });
      CallExpression(path, { file }) {
        const state = file.metadata.muiCSS as State;
        if (!state.enabled) {
          return;
        }
        const {
          callee: { name: calleeName },
          arguments: args,
        } = path.node;

        if (calleeName !== 'css') {
          return;
        }
        if (!t.isStringLiteral(args[0])) {
          throw new Error(`Invalid CSS prefix: ${formatLocation(file, path.node)}`);
        }
        if (!t.isObjectExpression(args[1])) {
          throw new Error(`Invalid CSS styles: ${formatLocation(file, path.node)}`);
        }

        const [prefixNode, classesNode] = args;

        const prefix = prefixNode.extra.rawValue;

        const source = file.code.slice(classesNode.start, classesNode.end);
        const result = vm.runInContext(
          `
          ${state.config.variablesCode};
          const result = ${source};
          result;
        `,
          vm.createContext({}),
        );

        const classes = result;

        path.replaceWith(buildClassesNode(file.metadata.muiCSS, prefix, classes));
      },
    },
  };

  function buildClassesNode(state: State, prefix: string, classes: Record<string, object>) {
    return t.objectExpression(
      Object.keys(classes).map((className) => {
        const identifier = className;
        const cssClassName = generateClassName(prefix, className);
        const cssStyles = classes[className];

        const generatedCSS = stylesToString(`.${cssClassName}`, cssStyles as any)
          .map((c) => c.trim())
          .join('\n');

        state.rules.push({
          content: generatedCSS,
        });

        return t.objectProperty(t.stringLiteral(identifier), t.stringLiteral(cssClassName));
      }),
    );
  }
}

function generateClassName(prefix: string, className: string) {
  if (className === 'root') {
    return prefix;
  }
  return `${prefix}--${className}`;
}

function getConfigPath(filepath: string) {
  const configPath = resolvePath(packageDirectorySync({ cwd: dirname(filepath) }), CONFIG_FILENAME);
  return configPath;
}

function getConfig(filepath: string) {
  const configPath = getConfigPath(filepath);
  let config = configsByPath.get(configPath);
  if (config !== undefined) {
    return config;
  }

  if (!existsSync(configPath)) {
    configsByPath.set(configPath, null);
    return null;
  }

  const data = JSON.parse(readFileSync(configPath).toString());
  config = {
    configPath,
    data,
    variablesCode: getCSSVariablesCode(
      data.cssVariables ? resolvePath(dirname(configPath), data.cssVariables) : undefined,
    ),
  };
  configsByPath.set(configPath, config);
  return config;
}

function findSelf(plugins) {
  return plugins.find((p) => p.key === PLUGIN_NAME);
}

function formatLocation(file: Babel.BabelFile, node: Babel.Node) {
  return `${file.opts.filename}:${node.loc.start.line}:${node.loc.start.column}`;
}

function getCSSVariablesCode(filepath: string | undefined) {
  if (filepath === undefined) {
    return '';
  }

  const code = readFileSync(filepath).toString();

  const result = ts.transpileModule(code, {
    fileName: filepath,
    compilerOptions: {
      module: ts.ModuleKind.CommonJS,
      target: ts.ScriptTarget.ES2016,
    },
  });

  if (result.diagnostics.length > 0) {
    console.error(`[mui-css] Errors compiling ${filepath}`);
    console.error(result.diagnostics);
  }

  return `const vars = (function(exports) {
    ${result.outputText}
    return exports
  })({}).vars;`;
}
