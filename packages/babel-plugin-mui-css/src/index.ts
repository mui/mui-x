import * as vm from 'node:vm';
import { writeFileSync } from 'node:fs';
import { dirname, basename, resolve as resolvePath } from 'node:path';
import * as Babel from '@babel/core';
import { getConfig, BuildTarget, type ProjectConfig } from './config.js';
import { stylesToString } from './css/stylesToString.js';

type BabelT = typeof Babel;

const PLUGIN_NAME = 'mui-css';

type State = {
  enabled: boolean;
  didReplace: boolean;
  options: any;
  config: ProjectConfig;
  rules: { content: string }[];
};

export default function transformCSS({ types: t }: BabelT) {
  const targetImpl = {
    [BuildTarget.CSS]: {
      compileNode(path: Babel.NodePath, params, prefix: string, styles: Record<string, object>) {
        const {
          callee: { name: calleeName },
          arguments: argumentNodes,
        } = path.node as any;

        const classesNode = buildClassesNode(params.file.metadata.muiCSS, prefix, styles);

        switch (calleeName) {
          case 'css': {
            path.replaceWith(classesNode);
            break;
          }
          case 'slot': {
            argumentNodes[1] = classesNode;
            break;
          }
          default:
        }
      },

      finalize(path: Babel.NodePath<Babel.types.Program>, params) {
        const state = params.file.metadata.muiCSS as State;

        const cssContent = state.rules.map((r) => r.content).join('\n');

        const filePath = params.file.opts.filename;
        const cssFilename = `${basename(filePath).split('.').slice(0, -1).join('.')}.autogenerated.css`;
        const outputPath = resolvePath(dirname(filePath), cssFilename);
        writeFileSync(outputPath, cssContent);

        path.node.body.unshift(t.importDeclaration([], t.stringLiteral(`./${cssFilename}`)));
      },
    },

    [BuildTarget.EMOTION]: {
      compileNode(path: Babel.NodePath, params, prefix: string, styles: Record<string, object>) {
        const state = params.file.metadata.muiCSS as State;
        const {
          callee: { name: calleeName },
          arguments: argumentNodes,
        } = path.node as any;

        const metaNode = argumentNodes[0];
        const stylesNode = argumentNodes[1] as Babel.types.ObjectExpression;

        const asNode = findObjectProperty(metaNode, 'as');
        const nameNode = findObjectProperty(metaNode, 'name');
        const slotNode = findObjectProperty(metaNode, 'slot');

        const styledNode = t.callExpression(t.identifier('styled'), [
          asNode.value as any,
          t.objectExpression([
            t.objectProperty(t.identifier('name'), nameNode.value),
            t.objectProperty(t.identifier('slot'), slotNode.value),
          ])
        ]);

        const rootStylesNode = findObjectProperty(stylesNode, 'root').value as Babel.types.ObjectExpression;
        const emotionStylesNode = t.cloneNode(rootStylesNode);
        stylesNode.properties.forEach(propertyNode => {
          if (propertyNode.type !== 'ObjectProperty' || propertyNode.key.type !== 'Identifier' ) {
            return
          }
          if (propertyNode.key.name === 'root') {
            return;
          }
          const modifier = propertyNode.key.name;
          const className = generateClassName(prefix, modifier, styles[modifier]);
          emotionStylesNode.properties.push(
            t.objectProperty(
              t.stringLiteral(`&.${className}`),
              t.cloneNode(propertyNode.value),
            )
          )
        });

        const styledCallNode = t.callExpression(
          styledNode,
          [emotionStylesNode]
        )

        // const classesNode = buildClassesNode(params.file.metadata.muiCSS, prefix, styles);

        switch (calleeName) {
          case 'css': {
            throw new Error('todo')
          }
          case 'slot': {
            path.replaceWith(styledCallNode);
            break;
          }
          default:
        }
      },

      finalize(path: Babel.NodePath<Babel.types.Program>, { file }) {
        const state = file.metadata.muiCSS as State;
        if (state.rules.length === 0) {
          return;
        }
        path.node.body.unshift(
          t.importDeclaration(
            [t.importSpecifier(t.identifier('styled'), t.identifier('styled'))],
            t.stringLiteral('@mui/material/styles'),
          ),
        );
      },
    },
  };

  return {
    name: PLUGIN_NAME,

    pre(file: Babel.BabelFile) {
      const options = findSelf(file.opts.plugins).options;
      const config = getConfig(file.opts.filename);
      (file.metadata as any).muiCSS = {
        enabled: config !== null && !file.opts.filename.includes('cssVariables'),
        didReplace: false,
        options,
        config,
        rules: [],
      } as State;
    },

    visitor: {
      CallExpression(path: Babel.NodePath, params) {
        const { file } = params;
        const state = file.metadata.muiCSS as State;
        if (!state.enabled) {
          return;
        }
        try {
          const {
            callee: { name: calleeName },
            arguments: argumentNodes,
          } = path.node as any;

          let prefix: string;
          let stylesNode: Babel.types.ObjectExpression;

          if (calleeName === 'css') {
            // const styles = css('prefix', {
            //   class1: { ... },
            // });
            const prefixNode = argumentNodes[0];
            stylesNode = argumentNodes[1];

            if (!t.isStringLiteral(prefixNode)) {
              throw new Error(`Invalid CSS prefix: ${formatLocation(file, path.node)}`);
            }
            if (!t.isObjectExpression(stylesNode)) {
              throw new Error(`Invalid CSS styles: ${formatLocation(file, path.node)}`);
            }

            prefix = prefixNode.extra.rawValue as string;
          } else if (calleeName === 'slot') {
            // const slotN = slot({ name: 'Grid', slot: 'label' }, {
            //   class1: { ... },
            // });
            const metaNode = argumentNodes[0];
            stylesNode = argumentNodes[1];

            if (!t.isObjectExpression(metaNode)) {
              throw new Error(`Invalid slot metadata: ${formatLocation(file, path.node)}`);
            }
            if (!t.isObjectExpression(stylesNode)) {
              throw new Error(`Invalid CSS styles: ${formatLocation(file, path.node)}`);
            }

            const nameNode = findObjectProperty(metaNode, 'name');
            const slotNode = findObjectProperty(metaNode, 'slot');

            const name = (nameNode as any).value.value;
            const slot = (slotNode as any).value.value;

            prefix = `${name}-${slot}`;
          } else {
            return;
          }

          state.didReplace = true;

          const stylesSource = file.code.slice(stylesNode.start, stylesNode.end);
          const styles = evaluateStyles(state, stylesSource);

          targetImpl[BuildTarget.EMOTION].compileNode(path, params, prefix, styles);
        } catch (error) {
          error.message = `[mui-css] Failed to compile styles for ${formatLocation(file, path.node)}: ${error.message}`;
          throw error;
        }
      },

      Program: {
        exit(path: Babel.NodePath<Babel.types.Program>, params: any) {
          const state = params.file.metadata.muiCSS as State;
          if (!state.enabled || !state.didReplace) {
            return;
          }
          targetImpl[BuildTarget.EMOTION].finalize(path, params);
        },
      },
    },
  };

  function buildClassesNode(state: State, prefix: string, styles: Record<string, object>) {
    return t.objectExpression(
      Object.keys(styles).map((identifier) => {
        const cssStyles = styles[identifier];
        const cssClassName = generateClassName(prefix, identifier, cssStyles);

        const generatedCSS = stylesToString(`.${cssClassName}`, cssStyles as any)
          .map((c) => c.trim())
          .join('\n');

        state.rules.push({
          content: generatedCSS,
        });

        return t.objectProperty(t.stringLiteral(identifier), t.stringLiteral(cssClassName));
      }),
    );
  }
}

function generateClassName(prefix: string, className: string, cssStyles: Record<string, any>) {
  /* eslint-disable no-underscore-dangle */
  if (cssStyles.__class__) {
    return cssStyles.__class__;
  }
  /* eslint-enable no-underscore-dangle */
  if (className === 'root') {
    return prefix;
  }
  return `${prefix}--${className}`;
}

function evaluateStyles(state: State, source: string) {
  return vm.runInContext(
    `
    ${state.config.variablesCode};
    const result = ${source};
    result;
  `,
    vm.createContext({}),
  );
}

function findObjectProperty(node: Babel.types.ObjectExpression, property: string): Babel.types.ObjectProperty {
  if (!node.properties) {
    throw new Error('Node is not an object:' + JSON.stringify(node))
  }
  const result = node.properties.find(
    (p) => p.type === 'ObjectProperty' && p.key.type === 'Identifier' && p.key.name === property,
  ) as any;
  if (!result) {
    throw new Error('Missing object property: ' + property);
  }
  return result;
}

function findSelf(plugins) {
  return plugins.find((p) => p.key === PLUGIN_NAME);
}

function formatLocation(file: Babel.BabelFile, node: Babel.Node) {
  return `${file.opts.filename}:${node.loc.start.line}:${node.loc.start.column}`;
}
