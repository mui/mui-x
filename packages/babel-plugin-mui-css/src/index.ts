import * as vm from 'node:vm';
import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { dirname, basename, resolve as resolvePath } from 'node:path';
import { packageDirectorySync } from 'pkg-dir';
import * as Babel from '@babel/core';
import * as ts from 'typescript';
import { stylesToString } from './css/stylesToString.js';

type BabelT = typeof Babel;

const PLUGIN_NAME = 'mui-css';
const CONFIG_FILENAME = 'mui-css.config.json';

type State = {
  enabled: boolean;
  options: any;
  config: ProjectConfig;
  rules: { content: string }[];
};

type ProjectConfig = {
  configPath: string;
  data: any;
  variablesCode: string | undefined;
};

const configsByPath = new Map<string, ProjectConfig | null>();

export default function transformCSS({ types: t }: BabelT) {
  return {
    name: PLUGIN_NAME,

    pre(file) {
      const options = findSelf(file.opts.plugins).options;
      const config = getConfig(file.opts.filename);
      file.metadata.muiCSS = {
        enabled: config !== null && !file.opts.filename.includes('cssVariables'),
        options,
        config,
        rules: [],
      } as State;
    },

    visitor: {
      Program: {
        exit(path, { file }) {
          const state = file.metadata.muiCSS as State;
          if (!state.enabled) {
            return;
          }
          if (state.rules.length === 0) {
            return;
          }

          const cssContent = state.rules.map((r) => r.content).join('\n');

          const filePath = file.opts.filename;
          const cssFilename = `${basename(filePath).split('.').slice(0, -1).join('.')}.autogenerated.css`;
          const outputPath = resolvePath(dirname(filePath), cssFilename);
          writeFileSync(outputPath, cssContent);

          path.node.body.unshift(t.importDeclaration([], t.stringLiteral(`./${cssFilename}`)));
        },
      },

      CallExpression(path: Babel.NodePath, { file }) {
        const state = file.metadata.muiCSS as State;
        if (!state.enabled) {
          return;
        }
        const {
          callee: { name: calleeName },
          arguments: args,
        } = path.node as any;

        let prefix: string;
        let sourceNode: Babel.types.ObjectExpression;

        if (calleeName === 'css') {
          // const styles = css('prefix', {
          //   class1: { ... },
          // });
          const [prefixNode, classesNode] = args;

          if (!t.isStringLiteral(prefixNode)) {
            throw new Error(`Invalid CSS prefix: ${formatLocation(file, path.node)}`);
          }
          if (!t.isObjectExpression(classesNode)) {
            throw new Error(`Invalid CSS styles: ${formatLocation(file, path.node)}`);
          }

          prefix = prefixNode.extra.rawValue as string;
          sourceNode = classesNode;
        } else if (calleeName === 'slot') {
          // const slotN = slot({ name: 'Grid', slot: 'label' }, {
          //   class1: { ... },
          // });
          const [metaNode, classesNode] = args;

          if (!t.isObjectExpression(metaNode)) {
            throw new Error(`Invalid slot metadata: ${formatLocation(file, path.node)}`);
          }
          if (!t.isObjectExpression(classesNode)) {
            throw new Error(`Invalid CSS styles: ${formatLocation(file, path.node)}`);
          }

          const nameNode = metaNode.properties.find(
            (p) =>
              p.type === 'ObjectProperty' && p.key.type === 'Identifier' && p.key.name === 'name',
          );
          const slotNode = metaNode.properties.find(
            (p) =>
              p.type === 'ObjectProperty' && p.key.type === 'Identifier' && p.key.name === 'slot',
          );

          const name = (nameNode as any).value.value;
          const slot = (slotNode as any).value.value;

          prefix = `${name}-${slot}`;
          sourceNode = classesNode;
        } else {
          return;
        }

        const source = file.code.slice(sourceNode.start, sourceNode.end);

        try {
          const result = vm.runInContext(
            `
            ${state.config.variablesCode};
            const result = ${source};
            result;
          `,
            vm.createContext({}),
          );

          const classes = result;

          switch (calleeName) {
            case 'css': {
              path.replaceWith(buildClassesNode(file.metadata.muiCSS, prefix, classes));
              break;
            }
            case 'slot': {
              args[1] = buildClassesNode(file.metadata.muiCSS, prefix, classes);
              break;
            }
            default:
          }
        } catch (error) {
          error.message = `[mui-css] Failed to compile styles for ${formatLocation(file, path.node)}: ${error.message}`;
          throw error;
        }
      },
    },
  };

  function buildClassesNode(state: State, prefix: string, classes: Record<string, object>) {
    return t.objectExpression(
      Object.keys(classes).map((className) => {
        const identifier = className;
        const cssClassName = generateClassName(prefix, className);
        const cssStyles = classes[className];

        const generatedCSS = stylesToString(`.${cssClassName}`, cssStyles as any)
          .map((c) => c.trim())
          .join('\n');

        state.rules.push({
          content: generatedCSS,
        });

        return t.objectProperty(t.stringLiteral(identifier), t.stringLiteral(cssClassName));
      }),
    );
  }
}

function generateClassName(prefix: string, className: string) {
  if (className === 'root') {
    return prefix;
  }
  return `${prefix}--${className}`;
}

function getConfigPath(filepath: string) {
  const configPath = resolvePath(packageDirectorySync({ cwd: dirname(filepath) }), CONFIG_FILENAME);
  return configPath;
}

function getConfig(filepath: string) {
  const configPath = getConfigPath(filepath);
  let config = configsByPath.get(configPath);
  if (config !== undefined) {
    return config;
  }

  if (!existsSync(configPath)) {
    configsByPath.set(configPath, null);
    return null;
  }

  const data = JSON.parse(readFileSync(configPath).toString());
  config = {
    configPath,
    data,
    variablesCode: getCSSVariablesCode(
      data.cssVariables ? resolvePath(dirname(configPath), data.cssVariables) : undefined,
    ),
  };
  configsByPath.set(configPath, config);
  return config;
}

function findSelf(plugins) {
  return plugins.find((p) => p.key === PLUGIN_NAME);
}

function formatLocation(file: Babel.BabelFile, node: Babel.Node) {
  return `${file.opts.filename}:${node.loc.start.line}:${node.loc.start.column}`;
}

function getCSSVariablesCode(filepath: string | undefined) {
  if (filepath === undefined) {
    return '';
  }

  const code = readFileSync(filepath).toString();

  const result = ts.transpileModule(code, {
    fileName: filepath,
    compilerOptions: {
      module: ts.ModuleKind.CommonJS,
      target: ts.ScriptTarget.ES2016,
    },
  });

  if (result.diagnostics.length > 0) {
    console.error(`[mui-css] Errors compiling ${filepath}`);
    console.error(result.diagnostics);
  }

  return `const vars = (function(exports) {
    ${result.outputText}
    return exports
  })({}).vars;`;
}
