import * as vm from 'node:vm';
import { writeFileSync } from 'node:fs';
import { dirname, basename, resolve as resolvePath } from 'node:path';
import * as Babel from '@babel/core';
import { getConfig, type ProjectConfig } from './config';
import { stylesToString } from './css/stylesToString';

type BabelT = typeof Babel;

const PLUGIN_NAME = 'mui-css';

type State = {
  enabled: boolean;
  options: any;
  config: ProjectConfig;
  rules: { content: string }[];
};

export default function transformCSS({ types: t }: BabelT) {
  return {
    name: PLUGIN_NAME,

    pre(file) {
      const options = findSelf(file.opts.plugins).options;
      const config = getConfig(file.opts.filename);
      file.metadata.muiCSS = {
        enabled: config !== null && !file.opts.filename.includes('cssVariables'),
        options,
        config,
        rules: [],
      } as State;
    },

    visitor: {
      Program: {
        exit(path, { file }) {
          const state = file.metadata.muiCSS as State;
          if (!state.enabled) {
            return;
          }
          if (state.rules.length === 0) {
            return;
          }

          const cssContent = state.rules.map((r) => r.content).join('\n');

          const filePath = file.opts.filename;
          const cssFilename = `${basename(filePath).split('.').slice(0, -1).join('.')}.autogenerated.css`;
          const outputPath = resolvePath(dirname(filePath), cssFilename);
          writeFileSync(outputPath, cssContent);

          path.node.body.unshift(t.importDeclaration([], t.stringLiteral(`./${cssFilename}`)));
        },
      },

      CallExpression(path: Babel.NodePath, { file }) {
        const state = file.metadata.muiCSS as State;
        if (!state.enabled) {
          return;
        }
        const {
          callee: { name: calleeName },
          arguments: args,
        } = path.node as any;

        let prefix: string;
        let sourceNode: Babel.types.ObjectExpression;

        if (calleeName === 'css') {
          // const styles = css('prefix', {
          //   class1: { ... },
          // });
          const [prefixNode, classesNode] = args;

          if (!t.isStringLiteral(prefixNode)) {
            throw new Error(`Invalid CSS prefix: ${formatLocation(file, path.node)}`);
          }
          if (!t.isObjectExpression(classesNode)) {
            throw new Error(`Invalid CSS styles: ${formatLocation(file, path.node)}`);
          }

          prefix = prefixNode.extra.rawValue as string;
          sourceNode = classesNode;
        } else if (calleeName === 'slot') {
          // const slotN = slot({ name: 'Grid', slot: 'label' }, {
          //   class1: { ... },
          // });
          const [metaNode, classesNode] = args;

          if (!t.isObjectExpression(metaNode)) {
            throw new Error(`Invalid slot metadata: ${formatLocation(file, path.node)}`);
          }
          if (!t.isObjectExpression(classesNode)) {
            throw new Error(`Invalid CSS styles: ${formatLocation(file, path.node)}`);
          }

          const nameNode = metaNode.properties.find(
            (p) =>
              p.type === 'ObjectProperty' && p.key.type === 'Identifier' && p.key.name === 'name',
          );
          const slotNode = metaNode.properties.find(
            (p) =>
              p.type === 'ObjectProperty' && p.key.type === 'Identifier' && p.key.name === 'slot',
          );

          const name = (nameNode as any).value.value;
          const slot = (slotNode as any).value.value;

          prefix = `${name}-${slot}`;
          sourceNode = classesNode;
        } else {
          return;
        }

        const source = file.code.slice(sourceNode.start, sourceNode.end);

        try {
          const result = vm.runInContext(
            `
            ${state.config.variablesCode};
            const result = ${source};
            result;
          `,
            vm.createContext({}),
          );

          const classes = result;

          switch (calleeName) {
            case 'css': {
              path.replaceWith(buildClassesNode(file.metadata.muiCSS, prefix, classes));
              break;
            }
            case 'slot': {
              args[1] = buildClassesNode(file.metadata.muiCSS, prefix, classes);
              break;
            }
            default:
          }
        } catch (error) {
          error.message = `[mui-css] Failed to compile styles for ${formatLocation(file, path.node)}: ${error.message}`;
          throw error;
        }
      },
    },
  };

  function buildClassesNode(state: State, prefix: string, classes: Record<string, object>) {
    return t.objectExpression(
      Object.keys(classes).map((className) => {
        const cssStyles = classes[className];
        const cssClassName = generateClassName(prefix, className, cssStyles);

        const generatedCSS = stylesToString(`.${cssClassName}`, cssStyles as any)
          .map((c) => c.trim())
          .join('\n');

        state.rules.push({
          content: generatedCSS,
        });

        return t.objectProperty(t.stringLiteral(className), t.stringLiteral(cssClassName));
      }),
    );
  }
}

function generateClassName(prefix: string, className: string, cssStyles: Record<string, any>) {
  /* eslint-disable no-underscore-dangle */
  if (cssStyles.__class__) {
    return cssStyles.__class__;
  }
  /* eslint-enable no-underscore-dangle */
  if (className === 'root') {
    return prefix;
  }
  return `${prefix}--${className}`;
}

function findSelf(plugins) {
  return plugins.find((p) => p.key === PLUGIN_NAME);
}

function formatLocation(file: Babel.BabelFile, node: Babel.Node) {
  return `${file.opts.filename}:${node.loc.start.line}:${node.loc.start.column}`;
}
