import { type Store } from '@base-ui/utils/store';

// ================================
// Types
// ================================

export type GridRowId = string | number;

export interface GridRowModel {
  id?: GridRowId;
  [key: string]: any;
}

export interface GridLeafNode {
  id: GridRowId;
  type: 'leaf';
  depth: number;
  parent: GridRowId;
  groupingKey: string | null;
}

export interface GridGroupNode {
  id: GridRowId;
  type: 'group';
  depth: number;
  parent: GridRowId | null;
  groupingKey: string | null;
  groupingField: string | null;
  children: GridRowId[];
  childrenFromPath: Record<string, GridRowId>;
  childrenExpanded: boolean;
  isAutoGenerated: boolean;
  footerId?: GridRowId;
}

export type GridTreeNode = GridLeafNode | GridGroupNode;

export type GridRowTreeConfig = Record<GridRowId, GridTreeNode>;

export type GridRowIdToModelLookup<R extends GridRowModel = GridRowModel> = Record<GridRowId, R>;

export const GRID_ROOT_GROUP_ID: GridRowId = 'auto-generated-group-node-root';

// ================================
// State
// ================================

export interface RowsState {
  dataRowIds: GridRowId[];
  dataRowIdToModelLookup: GridRowIdToModelLookup;
  tree: GridRowTreeConfig;
  treeDepths: Record<number, number>;
  totalRowCount: number;
  totalTopLevelRowCount: number;
  loading: boolean;
  groupingName: string;
}

export interface RowsOptions<TRow> {
  rows: TRow[];
  getRowId?: (row: TRow) => GridRowId;
  loading?: boolean;
  rowCount?: number;
}

// ================================
// API
// ================================

export interface RowsApi<TRow = any> {
  getRow: (id: GridRowId) => TRow | null;
  getRowId: (row: TRow) => GridRowId;
  getRowModels: () => Map<GridRowId, TRow>;
  getRowsCount: () => number;
  getAllRowIds: () => GridRowId[];
  setRows: (rows: TRow[]) => void;
  updateRows: (updates: Partial<TRow>[]) => void;
  getRowNode: (id: GridRowId) => GridTreeNode | null;
  setLoading: (loading: boolean) => void;
}

// ================================
// Utilities
// ================================

/**
 * Check if the id provided is valid.
 */
function checkGridRowIdIsValid(
  id: GridRowId,
  row: GridRowModel,
  detailErrorMessage: string = 'A row was provided without id in the rows prop:',
): void {
  if (id == null) {
    throw new Error(
      [
        'MUI X: The Data Grid component requires all rows to have a unique `id` property.',
        'Alternatively, you can use the `getRowId` prop to specify a custom id for each row.',
        detailErrorMessage,
        JSON.stringify(row),
      ].join('\n'),
    );
  }
}

/**
 * Get the row id from a row model.
 */
export function getRowIdFromRowModel<TRow extends GridRowModel>(
  rowModel: TRow,
  getRowId?: (row: TRow) => GridRowId,
  detailErrorMessage?: string,
): GridRowId {
  const id = getRowId ? getRowId(rowModel) : rowModel.id;
  checkGridRowIdIsValid(id as GridRowId, rowModel, detailErrorMessage);
  return id as GridRowId;
}

/**
 * Build the root group node for the row tree.
 */
function buildRootGroup(): GridGroupNode {
  return {
    type: 'group',
    id: GRID_ROOT_GROUP_ID,
    depth: -1,
    groupingField: null,
    groupingKey: null,
    isAutoGenerated: true,
    children: [],
    childrenFromPath: {},
    childrenExpanded: true,
    parent: null,
  };
}

// ================================
// State Initialization
// ================================

/**
 * Create the initial rows state from options.
 */
export function createRowsState<TRow extends GridRowModel>(
  data: TRow[],
  getRowId?: (row: TRow) => GridRowId,
  loading: boolean = false,
  rowCount?: number,
): RowsState {
  const dataRowIds: GridRowId[] = [];
  const dataRowIdToModelLookup: GridRowIdToModelLookup = {};
  const tree: GridRowTreeConfig = {};
  const treeDepths: Record<number, number> = { 0: 0 };

  // Build root group
  const rootGroup = buildRootGroup();

  for (let i = 0; i < data.length; i += 1) {
    const row = data[i];
    const id = getRowIdFromRowModel(row, getRowId);

    dataRowIds.push(id);
    dataRowIdToModelLookup[id] = row;

    // Create leaf node for each row
    const leafNode: GridLeafNode = {
      id,
      type: 'leaf',
      depth: 0,
      parent: GRID_ROOT_GROUP_ID,
      groupingKey: null,
    };

    tree[id] = leafNode;
    rootGroup.children.push(id);
  }

  tree[GRID_ROOT_GROUP_ID] = rootGroup;
  treeDepths[0] = dataRowIds.length;

  const totalRowCount = Math.max(rowCount ?? 0, dataRowIds.length);

  return {
    dataRowIds,
    dataRowIdToModelLookup,
    tree,
    treeDepths,
    totalRowCount,
    totalTopLevelRowCount: totalRowCount,
    loading,
    groupingName: 'flat',
  };
}

// ================================
// API Creation
// ================================

interface CoreState {
  rows: RowsState;
}

/**
 * Create the rows API methods.
 */
export function createRowsApi<TRow extends GridRowModel>(
  store: Store<CoreState>,
  options: RowsOptions<TRow>,
): RowsApi {
  const getRow = (id: GridRowId): GridRowModel | null => {
    const lookup = store.state.rows.dataRowIdToModelLookup;
    return lookup[id] ?? null;
  };

  const getRowId = <T extends GridRowModel>(row: T): GridRowId => {
    return getRowIdFromRowModel(row, options.getRowId as ((row: T) => GridRowId) | undefined);
  };

  const getRowModels = (): Map<GridRowId, GridRowModel> => {
    const { dataRowIds, dataRowIdToModelLookup } = store.state.rows;
    return new Map(dataRowIds.map((id: GridRowId) => [id, dataRowIdToModelLookup[id] ?? {}]));
  };

  const getRowsCount = (): number => {
    return store.state.rows.totalRowCount;
  };

  const getAllRowIds = (): GridRowId[] => {
    return store.state.rows.dataRowIds;
  };

  const setRows = (rows: GridRowModel[]): void => {
    const newRowsState = createRowsState(
      rows,
      options.getRowId as ((row: GridRowModel) => GridRowId) | undefined,
      store.state.rows.loading,
      options.rowCount,
    );
    store.setState({ ...store.state, rows: newRowsState });
  };

  const updateRows = (updates: GridRowModel[]): void => {
    const { dataRowIds, dataRowIdToModelLookup, tree, treeDepths } = store.state.rows;

    const newDataRowIds = [...dataRowIds];
    const newLookup = { ...dataRowIdToModelLookup };
    const newTree = { ...tree };
    const rootGroup = { ...(newTree[GRID_ROOT_GROUP_ID] as GridGroupNode) };
    rootGroup.children = [...rootGroup.children];

    for (const update of updates) {
      const id = getRowIdFromRowModel(
        update,
        options.getRowId as ((row: GridRowModel) => GridRowId) | undefined,
        'A row was provided without id when calling updateRows():',
      );

      // Check if this is a delete action
      // eslint-disable-next-line no-underscore-dangle
      if ('_action' in update && update._action === 'delete') {
        // Remove the row
        delete newLookup[id];
        delete newTree[id];
        const dataIndex = newDataRowIds.indexOf(id);
        if (dataIndex > -1) {
          newDataRowIds.splice(dataIndex, 1);
        }
        const childIndex = rootGroup.children.indexOf(id);
        if (childIndex > -1) {
          rootGroup.children.splice(childIndex, 1);
        }
      } else if (newLookup[id]) {
        // Update existing row
        newLookup[id] = { ...newLookup[id], ...update };
      } else {
        // Insert new row
        newDataRowIds.push(id);
        newLookup[id] = update;
        rootGroup.children.push(id);

        const leafNode: GridLeafNode = {
          id,
          type: 'leaf',
          depth: 0,
          parent: GRID_ROOT_GROUP_ID,
          groupingKey: null,
        };
        newTree[id] = leafNode;
      }
    }

    newTree[GRID_ROOT_GROUP_ID] = rootGroup;

    const totalRowCount = Math.max(options.rowCount ?? 0, newDataRowIds.length);

    store.setState({
      ...store.state,
      rows: {
        ...store.state.rows,
        dataRowIds: newDataRowIds,
        dataRowIdToModelLookup: newLookup,
        tree: newTree,
        treeDepths: { ...treeDepths, 0: newDataRowIds.length },
        totalRowCount,
        totalTopLevelRowCount: totalRowCount,
      },
    });
  };

  const getRowNode = (id: GridRowId): GridTreeNode | null => {
    return store.state.rows.tree[id] ?? null;
  };

  const setLoading = (loading: boolean): void => {
    store.setState({
      ...store.state,
      rows: { ...store.state.rows, loading },
    });
  };

  return {
    getRow,
    getRowId,
    getRowModels,
    getRowsCount,
    getAllRowIds,
    setRows,
    updateRows,
    getRowNode,
    setLoading,
  };
}
