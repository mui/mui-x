// ================================
// Types
// ================================

export type GridRowId = string | number;

export interface GridRowModel {
  id?: GridRowId;
  [key: string]: any;
}

export interface GridLeafNode {
  id: GridRowId;
  type: 'leaf';
  depth: number;
  parent: GridRowId;
  groupingKey: string | null;
}

export interface GridGroupNode {
  id: GridRowId;
  type: 'group';
  depth: number;
  parent: GridRowId | null;
  groupingKey: string | null;
  groupingField: string | null;
  children: GridRowId[];
  childrenFromPath: Record<string, GridRowId>;
  childrenExpanded: boolean;
  isAutoGenerated: boolean;
  footerId?: GridRowId;
}

export type GridTreeNode = GridLeafNode | GridGroupNode;

export type GridRowTreeConfig = Record<GridRowId, GridTreeNode>;

export type GridRowIdToModelLookup<R extends GridRowModel = GridRowModel> = Record<GridRowId, R>;

export const GRID_ROOT_GROUP_ID: GridRowId = 'auto-generated-group-node-root';

// ================================
// State
// ================================

export interface RowsState {
  dataRowIds: GridRowId[];
  dataRowIdToModelLookup: GridRowIdToModelLookup;
  tree: GridRowTreeConfig;
  treeDepths: Record<number, number>;
  totalRowCount: number;
  totalTopLevelRowCount: number;
  loading: boolean;
  groupingName: string;
  processedRowIds: GridRowId[];
}

export interface RowsOptions<TRow> {
  rows: TRow[];
  getRowId?: (row: TRow) => GridRowId;
  loading?: boolean;
  rowCount?: number;
}

// ================================
// API
// ================================

export interface RowIdsPipelineProcessor {
  /**
   * Transform the row IDs. Receives the output of the previous processor
   * (or raw dataRowIds for the first processor).
   */
  (inputIds: GridRowId[]): GridRowId[];
}

// ================================
// Utilities
// ================================

/**
 * Check if the id provided is valid.
 */
function checkGridRowIdIsValid(
  id: GridRowId,
  row: GridRowModel,
  detailErrorMessage: string = 'A row was provided without id in the rows prop:',
): void {
  if (id == null) {
    throw new Error(
      [
        'MUI X: The Data Grid component requires all rows to have a unique `id` property.',
        'Alternatively, you can use the `getRowId` prop to specify a custom id for each row.',
        detailErrorMessage,
        JSON.stringify(row),
      ].join('\n'),
    );
  }
}

/**
 * Get the row id from a row model.
 */
export function getRowIdFromRowModel<TRow extends GridRowModel>(
  rowModel: TRow,
  getRowId?: (row: TRow) => GridRowId,
  detailErrorMessage?: string,
): GridRowId {
  const id = getRowId ? getRowId(rowModel) : rowModel.id;
  checkGridRowIdIsValid(id as GridRowId, rowModel, detailErrorMessage);
  return id as GridRowId;
}

/**
 * Build the root group node for the row tree.
 */
function buildRootGroup(): GridGroupNode {
  return {
    type: 'group',
    id: GRID_ROOT_GROUP_ID,
    depth: -1,
    groupingField: null,
    groupingKey: null,
    isAutoGenerated: true,
    children: [],
    childrenFromPath: {},
    childrenExpanded: true,
    parent: null,
  };
}

// ================================
// State Initialization
// ================================

/**
 * Create the initial rows state from options.
 */
export function createRowsState<TRow extends GridRowModel>(
  data: TRow[],
  getRowId?: (row: TRow) => GridRowId,
  loading: boolean = false,
  rowCount?: number,
): RowsState {
  const dataRowIds: GridRowId[] = [];
  const dataRowIdToModelLookup: GridRowIdToModelLookup = {};
  const tree: GridRowTreeConfig = {};
  const treeDepths: Record<number, number> = { 0: 0 };

  // Build root group
  const rootGroup = buildRootGroup();

  for (let i = 0; i < data.length; i += 1) {
    const row = data[i];
    const id = getRowIdFromRowModel(row, getRowId);

    dataRowIds.push(id);
    dataRowIdToModelLookup[id] = row;

    // Create leaf node for each row
    const leafNode: GridLeafNode = {
      id,
      type: 'leaf',
      depth: 0,
      parent: GRID_ROOT_GROUP_ID,
      groupingKey: null,
    };

    tree[id] = leafNode;
    rootGroup.children.push(id);
  }

  tree[GRID_ROOT_GROUP_ID] = rootGroup;
  treeDepths[0] = dataRowIds.length;

  const totalRowCount = Math.max(rowCount ?? 0, dataRowIds.length);

  return {
    dataRowIds,
    dataRowIdToModelLookup,
    tree,
    treeDepths,
    totalRowCount,
    totalTopLevelRowCount: totalRowCount,
    loading,
    groupingName: 'flat',
    processedRowIds: dataRowIds,
  };
}
