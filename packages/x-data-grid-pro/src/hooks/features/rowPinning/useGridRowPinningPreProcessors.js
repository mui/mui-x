"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useGridRowPinningPreProcessors = void 0;
exports.addPinnedRow = addPinnedRow;
var React = require("react");
var internals_1 = require("@mui/x-data-grid/internals");
var x_data_grid_1 = require("@mui/x-data-grid");
var utils_1 = require("../../../utils/tree/utils");
function addPinnedRow(_a) {
    var _b;
    var _c, _d, _e, _f;
    var groupingParams = _a.groupingParams, rowModel = _a.rowModel, rowId = _a.rowId, position = _a.position, apiRef = _a.apiRef, isAutoGenerated = _a.isAutoGenerated;
    var dataRowIdToModelLookup = __assign({}, groupingParams.dataRowIdToModelLookup);
    var tree = __assign({}, groupingParams.tree);
    var treeDepths = __assign({}, groupingParams.treeDepths);
    // TODO: warn if id is already present in `props.rows`
    var node = {
        type: 'pinnedRow',
        id: rowId,
        depth: 0,
        parent: x_data_grid_1.GRID_ROOT_GROUP_ID,
        isAutoGenerated: isAutoGenerated,
    };
    (0, utils_1.insertNodeInTree)(node, tree, treeDepths, null);
    if (!isAutoGenerated) {
        dataRowIdToModelLookup[rowId] = rowModel;
    }
    // Do not push it to ids list so that pagination is not affected by pinned rows
    apiRef.current.caches.rows.dataRowIdToModelLookup[rowId] = __assign({}, rowModel);
    var previousPinnedRows = ((_c = groupingParams.additionalRowGroups) === null || _c === void 0 ? void 0 : _c.pinnedRows) || {};
    var newPinnedRow = { id: rowId, model: rowModel };
    if ((_f = (_e = (_d = groupingParams.additionalRowGroups) === null || _d === void 0 ? void 0 : _d.pinnedRows) === null || _e === void 0 ? void 0 : _e[position]) === null || _f === void 0 ? void 0 : _f.includes(newPinnedRow)) {
        return __assign(__assign({}, groupingParams), { dataRowIdToModelLookup: dataRowIdToModelLookup, tree: tree, treeDepths: treeDepths });
    }
    return __assign(__assign({}, groupingParams), { dataRowIdToModelLookup: dataRowIdToModelLookup, tree: tree, treeDepths: treeDepths, additionalRowGroups: __assign(__assign({}, groupingParams.additionalRowGroups), { pinnedRows: __assign(__assign({}, previousPinnedRows), (_b = {}, _b[position] = __spreadArray(__spreadArray([], (previousPinnedRows[position] || []), true), [newPinnedRow], false), _b)) }) });
}
var useGridRowPinningPreProcessors = function (apiRef) {
    var prevPinnedRowsCacheRef = React.useRef(null);
    var addPinnedRows = React.useCallback(function (groupingParams) {
        var _a, _b, _c, _d, _e, _f;
        var pinnedRowsCache = apiRef.current.caches.pinnedRows || {};
        var prevPinnedRowsCache = prevPinnedRowsCacheRef.current;
        prevPinnedRowsCacheRef.current = pinnedRowsCache;
        var newGroupingParams = __assign(__assign({}, groupingParams), { additionalRowGroups: __assign(__assign({}, groupingParams.additionalRowGroups), { 
                // reset pinned rows state
                pinnedRows: {} }) });
        if (prevPinnedRowsCache) {
            var pinnedRowCleanup = function (rowId) {
                var node = newGroupingParams.tree[rowId];
                if ((node === null || node === void 0 ? void 0 : node.type) === 'pinnedRow') {
                    delete newGroupingParams.tree[rowId];
                    delete newGroupingParams.dataRowIdToModelLookup[rowId];
                    delete apiRef.current.caches.rows.dataRowIdToModelLookup[rowId];
                }
            };
            (_a = prevPinnedRowsCache.topIds) === null || _a === void 0 ? void 0 : _a.forEach(pinnedRowCleanup);
            (_b = prevPinnedRowsCache.bottomIds) === null || _b === void 0 ? void 0 : _b.forEach(pinnedRowCleanup);
        }
        (_c = pinnedRowsCache.topIds) === null || _c === void 0 ? void 0 : _c.forEach(function (rowId) {
            newGroupingParams = addPinnedRow({
                groupingParams: newGroupingParams,
                rowModel: pinnedRowsCache.idLookup[rowId],
                rowId: rowId,
                position: 'top',
                apiRef: apiRef,
                isAutoGenerated: false,
            });
        });
        (_d = pinnedRowsCache.bottomIds) === null || _d === void 0 ? void 0 : _d.forEach(function (rowId) {
            newGroupingParams = addPinnedRow({
                groupingParams: newGroupingParams,
                rowModel: pinnedRowsCache.idLookup[rowId],
                rowId: rowId,
                position: 'bottom',
                apiRef: apiRef,
                isAutoGenerated: false,
            });
        });
        // If row with the same `id` is present both in `rows` and `pinnedRows` - remove it from the root group children
        if (((_e = pinnedRowsCache.bottomIds) === null || _e === void 0 ? void 0 : _e.length) || ((_f = pinnedRowsCache.topIds) === null || _f === void 0 ? void 0 : _f.length)) {
            var shouldKeepRow = function (rowId) {
                if (newGroupingParams.tree[rowId] && newGroupingParams.tree[rowId].type === 'pinnedRow') {
                    return false;
                }
                return true;
            };
            var rootGroupNode = newGroupingParams.tree[x_data_grid_1.GRID_ROOT_GROUP_ID];
            newGroupingParams.tree[x_data_grid_1.GRID_ROOT_GROUP_ID] = __assign(__assign({}, rootGroupNode), { children: rootGroupNode.children.filter(shouldKeepRow) });
            newGroupingParams.dataRowIds = newGroupingParams.dataRowIds.filter(shouldKeepRow);
        }
        return newGroupingParams;
    }, [apiRef]);
    (0, internals_1.useGridRegisterPipeProcessor)(apiRef, 'hydrateRows', addPinnedRows);
};
exports.useGridRowPinningPreProcessors = useGridRowPinningPreProcessors;
