"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.insertDataRowInTree = void 0;
var x_data_grid_1 = require("@mui/x-data-grid");
var utils_1 = require("./utils");
/**
 * Inserts a data row in a tree.
 * For each steps of its path:
 * - if a node exists with the same partial path, it will register this node as the ancestor of the data row.
 * - if not, it will create an auto-generated node and register it as ancestor of the data row.
 */
var insertDataRowInTree = function (_a) {
    var _b, _c;
    var id = _a.id, path = _a.path, updatedGroupsManager = _a.updatedGroupsManager, previousTree = _a.previousTree, tree = _a.tree, treeDepths = _a.treeDepths, onDuplicatePath = _a.onDuplicatePath, isGroupExpandedByDefault = _a.isGroupExpandedByDefault, defaultGroupingExpansionDepth = _a.defaultGroupingExpansionDepth, serverChildrenCount = _a.serverChildrenCount, groupsToFetch = _a.groupsToFetch;
    var parentNodeId = x_data_grid_1.GRID_ROOT_GROUP_ID;
    for (var depth = 0; depth < path.length; depth += 1) {
        var _d = path[depth], key = _d.key, field = _d.field;
        var fieldWithDefaultValue = field !== null && field !== void 0 ? field : '__no_field__';
        var keyWithDefaultValue = key !== null && key !== void 0 ? key : '__no_key__';
        var existingNodeIdWithPartialPath = (_c = (_b = tree[parentNodeId].childrenFromPath) === null || _b === void 0 ? void 0 : _b[fieldWithDefaultValue]) === null || _c === void 0 ? void 0 : _c[keyWithDefaultValue.toString()];
        // When we reach the last step of the path,
        // We need to create a node for the row passed to `insertNodeInTree`
        if (depth === path.length - 1) {
            // If no node matches the full path,
            // We create a leaf node for the data row.
            if (existingNodeIdWithPartialPath == null) {
                var node = void 0;
                if (serverChildrenCount !== undefined && serverChildrenCount !== 0) {
                    node = {
                        type: 'group',
                        id: id,
                        parent: parentNodeId,
                        path: path.map(function (step) { return step.key; }),
                        depth: depth,
                        isAutoGenerated: false,
                        groupingKey: key,
                        groupingField: field,
                        children: [],
                        childrenFromPath: {},
                        childrenExpanded: false,
                        serverChildrenCount: serverChildrenCount,
                    };
                    var shouldFetchChildren = (0, utils_1.checkGroupChildrenExpansion)(node, defaultGroupingExpansionDepth, isGroupExpandedByDefault);
                    if (shouldFetchChildren) {
                        groupsToFetch === null || groupsToFetch === void 0 ? void 0 : groupsToFetch.add(id);
                    }
                }
                else {
                    node = {
                        type: 'leaf',
                        id: id,
                        depth: depth,
                        parent: parentNodeId,
                        groupingKey: key,
                    };
                }
                updatedGroupsManager === null || updatedGroupsManager === void 0 ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');
                (0, utils_1.insertNodeInTree)(node, tree, treeDepths, previousTree);
            }
            else {
                var existingNodeWithPartialPath = tree[existingNodeIdWithPartialPath];
                // If we already have an auto-generated group matching the partial path,
                // We replace it with the node from of data row passed to `insertNodeInTree`
                if (existingNodeWithPartialPath.type === 'group' &&
                    existingNodeWithPartialPath.isAutoGenerated) {
                    updatedGroupsManager === null || updatedGroupsManager === void 0 ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'removeChildren');
                    updatedGroupsManager === null || updatedGroupsManager === void 0 ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');
                    (0, utils_1.updateGroupNodeIdAndAutoGenerated)({
                        tree: tree,
                        previousTree: previousTree,
                        treeDepths: treeDepths,
                        node: existingNodeWithPartialPath,
                        updatedNode: {
                            id: id,
                            isAutoGenerated: false,
                        },
                    });
                }
                else {
                    // If we have another row matching the partial path, then there is a duplicate in the dataset.
                    // We warn the user and skip the current row.
                    onDuplicatePath === null || onDuplicatePath === void 0 ? void 0 : onDuplicatePath(existingNodeIdWithPartialPath, id, path);
                }
            }
        }
        // For the intermediary steps of the path,
        // We need to make sure that there is a node matching the partial path.
        //
        // If no node matches the partial path,
        // We create an auto-generated group node.
        else if (existingNodeIdWithPartialPath == null) {
            var nodeId = (0, utils_1.getGroupRowIdFromPath)(path.slice(0, depth + 1));
            var autoGeneratedGroupNode = {
                type: 'group',
                id: nodeId,
                parent: parentNodeId,
                depth: depth,
                isAutoGenerated: true,
                groupingKey: key,
                groupingField: field,
                children: [],
                childrenFromPath: {},
                childrenExpanded: false,
            };
            updatedGroupsManager === null || updatedGroupsManager === void 0 ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');
            (0, utils_1.insertNodeInTree)((0, utils_1.updateGroupDefaultExpansion)(autoGeneratedGroupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault), tree, treeDepths, previousTree);
            parentNodeId = nodeId;
        }
        // For the intermediary steps of the path
        // If a node matches the partial path, we use it as parent for the next step
        else {
            var currentGroupNode = tree[existingNodeIdWithPartialPath];
            // If the node matching the partial path is not a group, we turn it into a group
            if (currentGroupNode.type !== 'group') {
                var groupNode = {
                    type: 'group',
                    id: currentGroupNode.id,
                    parent: currentGroupNode.parent,
                    depth: currentGroupNode.depth,
                    isAutoGenerated: false,
                    groupingKey: key,
                    groupingField: field,
                    children: [],
                    childrenFromPath: {},
                    childrenExpanded: false,
                };
                tree[existingNodeIdWithPartialPath] = (0, utils_1.updateGroupDefaultExpansion)(groupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault);
            }
            parentNodeId = currentGroupNode.id;
        }
    }
};
exports.insertDataRowInTree = insertDataRowInTree;
