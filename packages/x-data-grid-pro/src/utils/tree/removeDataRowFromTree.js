"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeDataRowFromTree = void 0;
var x_data_grid_1 = require("@mui/x-data-grid");
var utils_1 = require("./utils");
var gridTreeDataUtils_1 = require("../../hooks/features/treeData/gridTreeDataUtils");
var internals_1 = require("../../internals");
var removeNode = function (_a) {
    var node = _a.node, tree = _a.tree, treeDepths = _a.treeDepths;
    (0, utils_1.removeNodeFromTree)({
        node: node,
        tree: tree,
        treeDepths: treeDepths,
    });
    if (node.type === 'group' && node.footerId != null) {
        (0, utils_1.removeNodeFromTree)({
            node: tree[node.footerId],
            tree: tree,
            treeDepths: treeDepths,
        });
    }
};
var removeNodeAndCleanParent = function (_a) {
    var node = _a.node, tree = _a.tree, treeDepths = _a.treeDepths, updatedGroupsManager = _a.updatedGroupsManager;
    removeNode({ node: node, tree: tree, treeDepths: treeDepths });
    var parentNode = tree[node.parent];
    updatedGroupsManager === null || updatedGroupsManager === void 0 ? void 0 : updatedGroupsManager.addAction(parentNode.id, 'removeChildren');
    var shouldDeleteGroup = parentNode.id !== x_data_grid_1.GRID_ROOT_GROUP_ID && parentNode.children.length === 0;
    if (shouldDeleteGroup) {
        if (parentNode.isAutoGenerated) {
            removeNodeAndCleanParent({ node: parentNode, tree: tree, treeDepths: treeDepths });
        }
        else {
            tree[parentNode.id] = {
                type: 'leaf',
                id: parentNode.id,
                depth: parentNode.depth,
                parent: parentNode.parent,
                groupingKey: parentNode.groupingKey,
            };
        }
    }
};
var replaceDataGroupWithAutoGeneratedGroup = function (_a) {
    var node = _a.node, tree = _a.tree, treeDepths = _a.treeDepths, updatedGroupsManager = _a.updatedGroupsManager;
    updatedGroupsManager === null || updatedGroupsManager === void 0 ? void 0 : updatedGroupsManager.addAction(node.parent, 'removeChildren');
    updatedGroupsManager === null || updatedGroupsManager === void 0 ? void 0 : updatedGroupsManager.addAction(node.parent, 'insertChildren');
    (0, utils_1.updateGroupNodeIdAndAutoGenerated)({
        previousTree: null,
        tree: tree,
        treeDepths: treeDepths,
        node: node,
        updatedNode: {
            id: (0, utils_1.getGroupRowIdFromPath)((0, utils_1.getNodePathInTree)({ id: node.id, tree: tree })),
            isAutoGenerated: true,
        },
    });
};
/**
 * Removed a data row from the tree.
 * If the node is a non-empty group, replace it with an auto-generated group to be able to keep displaying its children.
 * If not, remove it and recursively clean its parent with the following rules:
 * - An empty auto-generated should be removed from the tree
 * - An empty non-auto-generated should be turned into a leaf
 */
var removeDataRowFromTree = function (_a) {
    var id = _a.id, tree = _a.tree, treeDepths = _a.treeDepths, updatedGroupsManager = _a.updatedGroupsManager, groupingName = _a.groupingName;
    var node = tree[id];
    if (node.type === 'group' && node.children.length > 0) {
        replaceDataGroupWithAutoGeneratedGroup({ node: node, tree: tree, treeDepths: treeDepths, updatedGroupsManager: updatedGroupsManager });
    }
    else if (groupingName === gridTreeDataUtils_1.TreeDataStrategy.Default ||
        groupingName === internals_1.RowGroupingStrategy.Default) {
        removeNodeAndCleanParent({ node: node, tree: tree, treeDepths: treeDepths, updatedGroupsManager: updatedGroupsManager });
    }
    else {
        removeNode({ node: node, tree: tree, treeDepths: treeDepths });
    }
};
exports.removeDataRowFromTree = removeDataRowFromTree;
