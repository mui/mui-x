"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVisibleRowsLookup = exports.createUpdatedGroupsManager = exports.updateGroupNodeIdAndAutoGenerated = exports.removeNodeFromTree = exports.insertNodeInTree = exports.updateGroupDefaultExpansion = exports.checkGroupChildrenExpansion = exports.getNodePathInTree = exports.getGroupRowIdFromPath = void 0;
var x_data_grid_1 = require("@mui/x-data-grid");
var getGroupRowIdFromPath = function (path) {
    var pathStr = path
        .map(function (groupingCriteria) { return "".concat(groupingCriteria.field, "/").concat(groupingCriteria.key); })
        .join('-');
    return "auto-generated-row-".concat(pathStr);
};
exports.getGroupRowIdFromPath = getGroupRowIdFromPath;
var getNodePathInTree = function (_a) {
    var id = _a.id, tree = _a.tree;
    var path = [];
    var node = tree[id];
    while (node.id !== x_data_grid_1.GRID_ROOT_GROUP_ID) {
        path.push({
            field: node.type === 'leaf' ? null : node.groupingField,
            key: node.groupingKey,
        });
        node = tree[node.parent];
    }
    path.reverse();
    return path;
};
exports.getNodePathInTree = getNodePathInTree;
var checkGroupChildrenExpansion = function (node, defaultGroupingExpansionDepth, isGroupExpandedByDefault) {
    var childrenExpanded;
    if (node.id === x_data_grid_1.GRID_ROOT_GROUP_ID) {
        childrenExpanded = true;
    }
    else if (isGroupExpandedByDefault) {
        childrenExpanded = isGroupExpandedByDefault(node);
    }
    else {
        childrenExpanded =
            defaultGroupingExpansionDepth === -1 || defaultGroupingExpansionDepth > node.depth;
    }
    return childrenExpanded;
};
exports.checkGroupChildrenExpansion = checkGroupChildrenExpansion;
var updateGroupDefaultExpansion = function (node, defaultGroupingExpansionDepth, isGroupExpandedByDefault) {
    var childrenExpanded = (0, exports.checkGroupChildrenExpansion)(node, defaultGroupingExpansionDepth, isGroupExpandedByDefault);
    node.childrenExpanded = childrenExpanded;
    return node;
};
exports.updateGroupDefaultExpansion = updateGroupDefaultExpansion;
/**
 * Insert a node in the tree
 */
var insertNodeInTree = function (node, tree, treeDepths, previousTree) {
    var _a;
    var _b, _c, _d, _e;
    // 1. Insert node in the tree.
    tree[node.id] = node;
    // 2. Increment the `treeDepths` object for the node's depth.
    treeDepths[node.depth] = ((_b = treeDepths[node.depth]) !== null && _b !== void 0 ? _b : 0) + 1;
    // 3. Register the new node in its parent.
    var parentNode = tree[node.parent];
    if (node.type === 'group' || node.type === 'leaf') {
        // For groups and leaves,
        // Register the node from its parents `children` and `childrenFromPath` properties.
        var groupingFieldName = (_c = node.groupingField) !== null && _c !== void 0 ? _c : '__no_field__';
        var groupingKeyName = (_d = node.groupingKey) !== null && _d !== void 0 ? _d : '__no_key__';
        var groupingField = (_e = parentNode.childrenFromPath) === null || _e === void 0 ? void 0 : _e[groupingFieldName];
        if (previousTree !== null && previousTree[parentNode.id] === tree[parentNode.id]) {
            parentNode.children = __spreadArray(__spreadArray([], parentNode.children, true), [node.id], false);
        }
        else {
            parentNode.children.push(node.id);
        }
        if (groupingField == null) {
            parentNode.childrenFromPath[groupingFieldName] = (_a = {},
                _a[groupingKeyName.toString()] = node.id,
                _a);
        }
        else {
            groupingField[groupingKeyName.toString()] = node.id;
        }
    }
    else if (node.type === 'footer') {
        // For footers,
        // Register the node from its parent `footerId` property.
        parentNode.footerId = node.id;
    }
};
exports.insertNodeInTree = insertNodeInTree;
/**
 * Removes a node from the tree
 */
var removeNodeFromTree = function (_a) {
    var _b, _c;
    var node = _a.node, tree = _a.tree, treeDepths = _a.treeDepths;
    // 1. Remove node from the tree.
    delete tree[node.id];
    // 2. Decrement the `treeDepths` object for the node's depth.
    var nodeDepth = node.depth;
    var currentNodeCount = treeDepths[nodeDepth];
    if (currentNodeCount === 1) {
        delete treeDepths[nodeDepth];
    }
    else {
        treeDepths[nodeDepth] = currentNodeCount - 1;
    }
    // 3. Unregister the new node in its parent.
    var parentNode = tree[node.parent];
    // For footers,
    // Unregister the node from its parent `footerId` property.
    if (node.type === 'footer') {
        tree[parentNode.id] = __assign(__assign({}, parentNode), { footerId: null });
    }
    // For groups and leaves,
    // Unregister the node from its parents `children` and `childrenFromPath` properties.
    else {
        var groupingField = (_b = node.groupingField) !== null && _b !== void 0 ? _b : '__no_field__';
        var groupingKey = (_c = node.groupingKey) !== null && _c !== void 0 ? _c : '__no_key__';
        // TODO rows v6: Can we avoid this linear complexity ?
        var children = parentNode.children.filter(function (childId) { return childId !== node.id; });
        var childrenFromPath = parentNode.childrenFromPath;
        delete childrenFromPath[groupingField][groupingKey.toString()];
        tree[parentNode.id] = __assign(__assign({}, parentNode), { children: children, childrenFromPath: childrenFromPath });
    }
};
exports.removeNodeFromTree = removeNodeFromTree;
/**
 * Updates the `id` and `isAutoGenerated` properties of a group node.
 */
var updateGroupNodeIdAndAutoGenerated = function (_a) {
    var node = _a.node, updatedNode = _a.updatedNode, previousTree = _a.previousTree, tree = _a.tree, treeDepths = _a.treeDepths;
    // 1. Set the new parent for all children from the old group
    node.children.forEach(function (childId) {
        tree[childId] = __assign(__assign({}, tree[childId]), { parent: updatedNode.id });
    });
    // 2. Remove the old group from the tree
    (0, exports.removeNodeFromTree)({
        node: node,
        tree: tree,
        treeDepths: treeDepths,
    });
    // 3. Add the new group in the tree
    var groupNode = __assign(__assign({}, node), updatedNode);
    (0, exports.insertNodeInTree)(groupNode, tree, treeDepths, previousTree);
};
exports.updateGroupNodeIdAndAutoGenerated = updateGroupNodeIdAndAutoGenerated;
var createUpdatedGroupsManager = function () { return ({
    value: {},
    addAction: function (groupId, action) {
        if (!this.value[groupId]) {
            this.value[groupId] = {};
        }
        this.value[groupId][action] = true;
    },
}); };
exports.createUpdatedGroupsManager = createUpdatedGroupsManager;
var getVisibleRowsLookup = function (_a) {
    var tree = _a.tree, filteredRowsLookup = _a.filteredRowsLookup;
    if (!filteredRowsLookup) {
        return {};
    }
    var visibleRowsLookup = {};
    var handleTreeNode = function (node, areAncestorsExpanded) {
        var isPassingFiltering = filteredRowsLookup[node.id] !== false;
        if (node.type === 'group') {
            node.children.forEach(function (childId) {
                var childNode = tree[childId];
                handleTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded);
            });
        }
        var isVisible = isPassingFiltering && areAncestorsExpanded;
        if (!isVisible) {
            visibleRowsLookup[node.id] = isVisible;
        }
        // TODO rows v6: Should we keep storing the visibility status of footer independently or rely on the group visibility in the selector ?
        if (node.type === 'group' && node.footerId != null) {
            var isFooterVisible = isPassingFiltering && areAncestorsExpanded && !!node.childrenExpanded;
            if (!isFooterVisible) {
                visibleRowsLookup[node.footerId] = isFooterVisible;
            }
        }
    };
    var nodes = Object.values(tree);
    for (var i = 0; i < nodes.length; i += 1) {
        var node = nodes[i];
        if (node.depth === 0) {
            handleTreeNode(node, true);
        }
    }
    return visibleRowsLookup;
};
exports.getVisibleRowsLookup = getVisibleRowsLookup;
