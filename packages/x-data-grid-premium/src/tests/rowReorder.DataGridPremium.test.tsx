import * as React from 'react';
import { spy } from 'sinon';
import {
  createRenderer,
  fireEvent,
  createEvent,
  screen,
  waitFor,
  act,
} from '@mui/internal-test-utils';
import { getColumnValues, getRow } from 'test/utils/helperFn';
import {
  DataGridPremium,
  DataGridPremiumProps,
  gridClasses,
  GridRowsProp,
  GridGroupNode,
  GridApi,
  GridDataSource,
  GridValidRowModel,
} from '@mui/x-data-grid-premium';
import { isJSDOM } from 'test/utils/skipIf';

// Helper function to create drag over event with coordinates
function createDragOverEvent(target: ChildNode, dropPosition: 'above' | 'below' = 'above') {
  const dragOverEvent = createEvent.dragOver(target);
  // Safari 13 doesn't have DragEvent.
  // RTL fallbacks to Event which doesn't allow to set these fields during initialization.
  Object.defineProperty(dragOverEvent, 'clientX', { value: 1 });

  // Mock getBoundingClientRect for the target
  const targetElement = target as Element;
  if (!targetElement.getBoundingClientRect) {
    targetElement.getBoundingClientRect = () => ({
      top: 0,
      left: 0,
      width: 100,
      height: 52,
      right: 100,
      bottom: 52,
      x: 0,
      y: 0,
      toJSON: () => {},
    });
  }

  // Set clientY based on drop position - relative to getBoundingClientRect
  const rect = targetElement.getBoundingClientRect();
  const clientY =
    dropPosition === 'above'
      ? rect.top + rect.height * 0.25 // Upper quarter
      : rect.top + rect.height * 0.75; // Lower quarter

  Object.defineProperty(dragOverEvent, 'clientY', { value: clientY });
  Object.defineProperty(dragOverEvent, 'target', { value: target });
  Object.defineProperty(dragOverEvent, 'dataTransfer', {
    value: {
      dropEffect: 'copy',
    },
  });

  return dragOverEvent;
}

function fireDragStart(target: ChildNode) {
  const dragStartEvent = createEvent.dragStart(target);
  Object.defineProperty(dragStartEvent, 'dataTransfer', {
    value: {
      effectAllowed: 'copy',
      setData: () => {},
      getData: () => '',
    },
  });
  fireEvent(target, dragStartEvent);
}

// Helper function to create drag end event
function createDragEndEvent(target: ChildNode, isOutsideTheGrid: boolean = false) {
  const dragEndEvent = createEvent.dragEnd(target);
  Object.defineProperty(dragEndEvent, 'dataTransfer', {
    value: { dropEffect: isOutsideTheGrid ? 'none' : 'copy' },
  });
  return dragEndEvent;
}

// Helper function to perform complete drag and drop operation
function performDragReorder(
  sourceRowElement: HTMLElement,
  targetRowElement: HTMLElement,
  dropPosition: 'above' | 'below' = 'above',
) {
  const sourceCell = sourceRowElement.querySelector('[role="gridcell"]')!.firstChild!;
  const targetCell = targetRowElement.querySelector('[role="gridcell"]')!;

  // Start drag - create event with dataTransfer
  fireDragStart(sourceCell);

  fireEvent.dragEnter(targetCell);

  // Drag over with position
  const dragOverEvent = createDragOverEvent(targetCell, dropPosition);
  fireEvent(targetCell, dragOverEvent);

  // End drag
  const dragEndEvent = createDragEndEvent(sourceCell);
  fireEvent(sourceCell, dragEndEvent);
}

// Test data for single-level grouping
const singleLevelData: GridRowsProp = [
  { id: 1, category: 'A', name: 'Item A1', value: 10 },
  { id: 2, category: 'A', name: 'Item A2', value: 20 },
  { id: 3, category: 'A', name: 'Item A3', value: 30 },
  { id: 4, category: 'B', name: 'Item B1', value: 40 },
  { id: 5, category: 'B', name: 'Item B2', value: 50 },
  { id: 6, category: 'C', name: 'Item C1', value: 60 },
  { id: 7, category: 'C', name: 'Item C2', value: 70 },
  { id: 8, category: 'C', name: 'Item C3', value: 80 },
  { id: 9, category: null, name: 'Item Null1', value: 90 },
  { id: 10, category: null, name: 'Item Null2', value: 100 },
];

const getRowGroupingDataBasedOnCategory = (
  groupKeys: string[],
): { rows: GridValidRowModel[]; rowCount: number } => {
  const categoryMap = new Map<string, GridValidRowModel[]>();
  for (const row of singleLevelData) {
    if (row.category) {
      categoryMap.set(row.category, [...(categoryMap.get(row.category) || []), row]);
    }
  }
  if (groupKeys.length === 0) {
    const rows = Array.from(categoryMap.keys()).map((category) => {
      return {
        id: `autogenerated-parent-category-${category}`,
        group: category,
        childrenCount: categoryMap.get(category)?.length ?? 0,
      };
    });
    return {
      rows,
      rowCount: categoryMap.size,
    };
  }
  if (groupKeys.length === 1) {
    const key = groupKeys[0].split('-').pop()!;
    return { rows: categoryMap.get(key)!, rowCount: categoryMap.size };
  }

  return {
    rows: [],
    rowCount: 0,
  };
};

// Test data for multi-level grouping
const multiLevelData: GridRowsProp = [
  { id: 1, company: 'Microsoft', dept: 'Engineering', team: 'Frontend', name: 'John' },
  { id: 2, company: 'Microsoft', dept: 'Engineering', team: 'Frontend', name: 'Jane' },
  { id: 3, company: 'Microsoft', dept: 'Engineering', team: 'Backend', name: 'Bob' },
  { id: 4, company: 'Microsoft', dept: 'Sales', team: 'Direct', name: 'Alice' },
  { id: 5, company: 'Microsoft', dept: 'Sales', team: 'Direct', name: 'Charlie' },
  { id: 6, company: 'Google', dept: 'Engineering', team: 'Frontend', name: 'David' },
  { id: 7, company: 'Google', dept: 'Engineering', team: 'Frontend', name: 'Eve' },
  { id: 8, company: 'Google', dept: 'Engineering', team: 'Backend', name: 'Frank' },
  { id: 9, company: 'Apple', dept: 'Design', team: 'UX', name: 'Grace' },
  { id: 10, company: 'Apple', dept: 'Design', team: 'UX', name: 'Henry' },
];

describe.skipIf(isJSDOM)('<DataGridPremium /> - Row reorder with row grouping', () => {
  const { render } = createRenderer();

  describe('Single-level row grouping', () => {
    const baselineProps: DataGridPremiumProps = {
      rows: singleLevelData,
      columns: [
        { field: 'category', width: 150 },
        { field: 'name', width: 150 },
        { field: 'value', width: 100, type: 'number' },
      ],
      initialState: {
        rowGrouping: {
          model: ['category'],
        },
      },
      defaultGroupingExpansionDepth: -1, // Expand all groups
      rowReordering: true,
      disableVirtualization: true,
      autoHeight: isJSDOM,
    };

    describe('Valid reorder cases', () => {
      it('should reorder leaves within same parent group', () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} />
          </div>,
        );

        // Initial order in category A
        // Column 3 has the item names
        expect(getColumnValues(3)).to.include('Item A1');
        expect(getColumnValues(3)).to.include('Item A2');
        expect(getColumnValues(3)).to.include('Item A3');

        // Get row elements (A1 is at row 3, A3 is at row 5)
        const itemA1Row = getRow(3);
        const itemA3Row = getRow(5);

        // Drag Item A1 to Item A3 position (below)
        performDragReorder(itemA1Row, itemA3Row, 'below');

        // Verify new order: A2, A3, A1
        const newValues = getColumnValues(3);
        const a2Index = newValues.indexOf('Item A2');
        const a3Index = newValues.indexOf('Item A3');
        const a1Index = newValues.indexOf('Item A1');

        expect(a2Index).to.be.lessThan(a3Index);
        expect(a3Index).to.be.lessThan(a1Index);
      });

      it('should move leaf between different parent groups', () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} />
          </div>,
        );

        // Get initial group counts
        const initialGroupingValues = getColumnValues(1);
        expect(initialGroupingValues[2]).to.match(/A \(3\)/); // Category A has 3 items
        expect(initialGroupingValues[6]).to.match(/B \(2\)/); // Category B has 2 items

        // Get row elements (A1 is at row 3, B1 is at row 7)
        const itemA1Row = getRow(3);
        const itemB1Row = getRow(7);

        // Drag Item A1 to Item B1 position (above)
        performDragReorder(itemA1Row, itemB1Row, 'above');

        // Verify group counts updated
        const newGroupingValues = getColumnValues(1);
        expect(newGroupingValues[2]).to.match(/A \(2\)/); // Category A now has 2 items
        expect(newGroupingValues[5]).to.match(/B \(3\)/); // Category B now has 3 items

        // Verify Item A1 is now in Category B
        const nameValues = getColumnValues(3);
        const a1Index = nameValues.indexOf('Item A1');
        const b1Index = nameValues.indexOf('Item B1');
        const a3Index = nameValues.indexOf('Item A3');

        expect(a1Index).to.be.lessThan(b1Index); // A1 is before B1
        expect(a1Index).to.be.greaterThan(2); // A1 is after remaining A items
        expect(a1Index).to.be.greaterThan(a3Index); // A1 is after A3
      });

      it('should reorder groups at the same level when groups are expanded and the source group is drop on "above" portion of the target group', () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} />
          </div>,
        );

        // Get group rows
        const groupARow = getRow(2); // Category A group
        const groupCRow = getRow(9); // Category C group

        // Drag Category A to Category C position
        performDragReorder(groupARow, groupCRow, 'above');

        // Verify new group order: B, A, C
        const groupingValues = getColumnValues(1);
        const groupBIndex = groupingValues.findIndex((v) => v?.includes('B ('));
        const groupAIndex = groupingValues.findIndex((v) => v?.includes('A ('));
        const groupCIndex = groupingValues.findIndex((v) => v?.includes('C ('));

        expect(groupBIndex).to.be.lessThan(groupAIndex);
        expect(groupAIndex).to.be.lessThan(groupCIndex);
      });

      it.skip('should reorder groups at the same level when groups are expanded and the source group is drop on "below" portion of the last group child', () => {
        // TODO: Add this functionality
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} />
          </div>,
        );

        // Get group rows
        const groupARow = getRow(2); // Category A group
        const lastChildOfC = getRow(12); // Category C group

        // Drag Category A to Category C position
        performDragReorder(groupARow, lastChildOfC, 'below');

        // Verify new group order: B, C, A
        const groupingValues = getColumnValues(1);
        const groupBIndex = groupingValues.findIndex((v) => v?.includes('B ('));
        const groupCIndex = groupingValues.findIndex((v) => v?.includes('C ('));
        const groupAIndex = groupingValues.findIndex((v) => v?.includes('A ('));

        expect(groupBIndex).to.be.lessThan(groupCIndex);
        expect(groupCIndex).to.be.lessThan(groupAIndex);
      });

      it('should handle leaf to group "above" when previous leaf exists', () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} />
          </div>,
        );

        // Get row elements
        const itemC1Row = getRow(10); // Item C1
        const groupBRow = getRow(6); // Category B group

        // Drag Item C1 to Category B position (above)
        // This should place C1 as the last child of Category A
        performDragReorder(itemC1Row, groupBRow, 'above');

        // Verify Item C1 is now the last item in Category A
        const nameValues = getColumnValues(3);
        const c1Index = nameValues.indexOf('Item C1');
        const a3Index = nameValues.indexOf('Item A3');
        const b1Index = nameValues.indexOf('Item B1');

        expect(c1Index).to.be.greaterThan(a3Index); // After A3
        expect(c1Index).to.be.lessThan(b1Index); // Before B group items
      });

      it('should handle leaf to group "below" when group is expanded', () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} />
          </div>,
        );

        // Get row elements
        const itemA1Row = getRow(3); // Item A1
        const groupBRow = getRow(6); // Category B group

        // Drag Item A1 to Category B position (below)
        // This should place A1 as the first child of Category B
        performDragReorder(itemA1Row, groupBRow, 'below');

        // Verify Item A1 is now the first item in Category B
        const nameValues = getColumnValues(3);
        const a1Index = nameValues.indexOf('Item A1');
        const b1Index = nameValues.indexOf('Item B1');
        const a2Index = nameValues.indexOf('Item A2');

        expect(a1Index).to.be.greaterThan(a2Index); // After remaining A items
        expect(a1Index).to.be.lessThan(b1Index); // Before original B items
      });

      it('should reorder group rows with collapsed groups', () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium
              {...baselineProps}
              defaultGroupingExpansionDepth={0} // All groups collapsed by default
              isGroupExpandedByDefault={(node: GridGroupNode) => {
                // Expand only category B
                return node.groupingKey === 'B';
              }}
            />
          </div>,
        );

        // Initial state: A collapsed, B expanded, C collapsed
        const groupingValues = getColumnValues(1);

        // Find group indices
        const groupAIndex = groupingValues.findIndex((v) => v?.includes('A ('));
        const groupCIndex = groupingValues.findIndex((v) => v?.includes('C ('));

        // Test 1: Reorder collapsed group A to after group C
        const groupARow = getRow(groupAIndex);
        const groupCRow = getRow(groupCIndex);

        performDragReorder(groupARow, groupCRow, 'below');

        // Verify new order: B, C, A
        const newGroupingValues = getColumnValues(1);
        const newGroupBIndex = newGroupingValues.findIndex((v) => v?.includes('B ('));
        const newGroupCIndex = newGroupingValues.findIndex((v) => v?.includes('C ('));
        const newGroupAIndex = newGroupingValues.findIndex((v) => v?.includes('A ('));

        expect(newGroupBIndex).to.be.lessThan(newGroupCIndex);
        expect(newGroupCIndex).to.be.lessThan(newGroupAIndex);

        // Test 2: Reorder collapsed group with expanded group
        // Move collapsed group C before expanded group B
        const groupBRow = getRow(newGroupBIndex);
        const groupCRowUpdated = getRow(newGroupCIndex);

        performDragReorder(groupCRowUpdated, groupBRow, 'above');

        // Verify new order: C, B, A
        const finalGroupingValues = getColumnValues(1);
        const finalGroupCIndex = finalGroupingValues.findIndex((v) => v?.includes('C ('));
        const finalGroupBIndex = finalGroupingValues.findIndex((v) => v?.includes('B ('));
        const finalGroupAIndex = finalGroupingValues.findIndex((v) => v?.includes('A ('));

        expect(finalGroupCIndex).to.be.lessThan(finalGroupBIndex);
        expect(finalGroupBIndex).to.be.lessThan(finalGroupAIndex);

        // Verify that collapsed group C remains collapsed
        const nameValues = getColumnValues(3);
        expect(nameValues.indexOf('Item C1')).to.equal(-1); // C's children should not be visible
      });

      it('should auto-expand collapsed group when leaf is dragged over it', async () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium
              {...baselineProps}
              defaultGroupingExpansionDepth={0} // All groups collapsed by default
              isGroupExpandedByDefault={(node: GridGroupNode) => {
                // Expand only category B
                return node.groupingKey === 'B';
              }}
            />
          </div>,
        );

        // Initial state: A collapsed, B expanded, C collapsed
        const groupingValues = getColumnValues(1);
        const groupAIndex = groupingValues.findIndex((v) => v?.includes('A ('));

        // Get Item B1 from expanded group B
        const nameValues = getColumnValues(3);
        const b1Index = nameValues.indexOf('Item B1');
        const itemB1Row = getRow(b1Index);
        const groupARow = getRow(groupAIndex);

        const sourceCell = itemB1Row.querySelector('[role="gridcell"]')!.firstChild!;
        const targetCell = groupARow.querySelector('[role="gridcell"]')!;

        // Start drag
        fireDragStart(sourceCell);
        fireEvent.dragEnter(targetCell);

        // Drag over collapsed group A
        const dragOverEvent = createDragOverEvent(targetCell, 'below');
        fireEvent(targetCell, dragOverEvent);

        // Verify group A is still collapsed initially
        let currentNameValues = getColumnValues(3);
        expect(currentNameValues.indexOf('Item A1')).to.equal(-1);

        // Wait for auto-expand after 500ms
        await waitFor(
          () => {
            currentNameValues = getColumnValues(3);
            // Group A should auto-expand, showing its children
            expect(currentNameValues.indexOf('Item A1')).to.not.equal(-1);
          },
          { timeout: 1000 },
        );

        // Complete the drag
        const dragEndEvent = createDragEndEvent(sourceCell);
        fireEvent(sourceCell, dragEndEvent);

        // Just verify the auto-expand worked - the drop may be rejected as invalid
        // since dropping a leaf on a group row may not be allowed in all cases
        const finalNameValues = getColumnValues(3);

        // Verify group A is expanded (its children are visible)
        expect(finalNameValues.indexOf('Item A1')).to.not.equal(-1);
        expect(finalNameValues.indexOf('Item A2')).to.not.equal(-1);
        expect(finalNameValues.indexOf('Item A3')).to.not.equal(-1);
      });
    });

    describe('Invalid reorder cases', () => {
      it('should not allow adjacent position movements', () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} />
          </div>,
        );

        const initialValues = getColumnValues(3);

        // Get row elements
        const itemA1Row = getRow(1);
        const itemA2Row = getRow(2);

        // Try to drag Item A1 to Item A2 position (above) - adjacent position
        performDragReorder(itemA1Row, itemA2Row, 'above');

        // Verify no change
        const newValues = getColumnValues(3);
        expect(newValues).to.deep.equal(initialValues);
      });

      it('should not allow group to be dropped on leaf', () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} />
          </div>,
        );

        const initialValues = getColumnValues(1);

        // Get row elements
        const groupARow = getRow(0); // Category A group
        const itemB1Row = getRow(5); // Item B1

        // Try to drag Category A to Item B1 position
        performDragReorder(groupARow, itemB1Row, 'above');

        // Verify no change
        const newValues = getColumnValues(1);
        expect(newValues).to.deep.equal(initialValues);
      });

      it('should show drop indicator during valid drag but remove on invalid drop', () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} />
          </div>,
        );

        // Get row elements
        const itemA1Row = getRow(3);
        const itemB1Row = getRow(7);

        const sourceCell = itemA1Row.querySelector('[role="gridcell"]')!.firstChild!;
        const targetCell = itemB1Row.querySelector('[role="gridcell"]')!;

        // Start drag with dataTransfer
        fireDragStart(sourceCell);
        fireEvent.dragEnter(targetCell);

        // Drag over - should show indicator
        const dragOverEvent = createDragOverEvent(targetCell, 'above');
        fireEvent(targetCell, dragOverEvent);

        const targetRow = targetCell.closest('[data-id]');
        // Check for drop indicator class
        expect(targetRow).to.have.class(gridClasses['row--dropAbove']);

        // End drag outside grid
        const dragEndEvent = createDragEndEvent(sourceCell, true);
        fireEvent(sourceCell, dragEndEvent);

        // Verify indicator removed
        expect(itemB1Row).not.to.have.class(gridClasses['row--dropAbove']);
        expect(itemB1Row).not.to.have.class(gridClasses['row--dropBelow']);
      });

      it('should not allow group to be dropped on collapsed group', async () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium
              {...baselineProps}
              isGroupExpandedByDefault={(node) => node.groupingKey === 'B'}
            />
          </div>,
        );

        // Expand group B
        const bIndex = getColumnValues(1).indexOf('B (2)');
        const groupValues = getColumnValues(1);

        // Grab B's first child and try to drop on the collapsed A
        const groupBChild = getRow(bIndex + 1);
        const groupARow = getRow(groupValues.indexOf('A (3)'));

        const sourceCell = groupBChild.querySelector('[role="gridcell"]')!.firstChild!;
        const targetCell = groupARow.querySelector('[role="gridcell"]')!;

        // Start drag with dataTransfer
        fireDragStart(sourceCell);
        fireEvent.dragEnter(targetCell);

        // Drag over - should show indicator
        const dragOverEvent = createDragOverEvent(targetCell, 'below');
        fireEvent(targetCell, dragOverEvent);

        const targetRow = targetCell.closest('[data-id]');
        // Check for drop indicator class
        expect(targetRow).not.to.have.class(gridClasses['row--dropBelow']);
      });
    });

    describe('Usage with `groupingValueSetter`', () => {
      it('should call groupingValueSetter when moving leaf between groups with complex category data', () => {
        const groupingValueSetter = spy((groupingValue, row, _column, _apiRef) => {
          // Update category with complex nested data structure
          return {
            ...row,
            category: {
              main: groupingValue,
              sub: (row.category as any)?.sub || 'General',
            },
          };
        });

        const complexCategoryData: GridRowsProp = [
          { id: 1, category: { main: 'Electronics', sub: 'Phones' }, name: 'iPhone', price: 999 },
          {
            id: 2,
            category: { main: 'Electronics', sub: 'Laptops' },
            name: 'MacBook',
            price: 1999,
          },
          { id: 3, category: { main: 'Clothing', sub: 'Shirts' }, name: 'T-Shirt', price: 25 },
          { id: 4, category: { main: 'Clothing', sub: 'Pants' }, name: 'Jeans', price: 60 },
        ];

        const complexProps: DataGridPremiumProps = {
          rows: complexCategoryData,
          columns: [
            {
              field: 'category',
              width: 150,
              groupingValueGetter: (value: any) => value?.main || 'Uncategorized',
              groupingValueSetter,
              valueGetter: (value: any) => value?.main || 'Uncategorized',
            },
            { field: 'name', width: 150 },
            { field: 'price', width: 100, type: 'number' },
          ],
          initialState: {
            rowGrouping: {
              model: ['category'],
            },
          },
          defaultGroupingExpansionDepth: -1,
          rowReordering: true,
          disableVirtualization: true,
          autoHeight: isJSDOM,
        };

        const apiRef = React.createRef<GridApi>();
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...complexProps} apiRef={apiRef} />
          </div>,
        );

        // Verify initial grouping - iPhone should be in Electronics group
        const initialGroupingValues = getColumnValues(1);
        expect(initialGroupingValues).to.include('Electronics (2)');
        expect(initialGroupingValues).to.include('Clothing (2)');

        // Find the actual iPhone and T-Shirt rows (names are in column 3)
        const nameValues = getColumnValues(3);
        const iPhoneRowIndex = nameValues.indexOf('iPhone');
        const tShirtRowIndex = nameValues.indexOf('T-Shirt');

        expect(iPhoneRowIndex).to.not.equal(-1, 'iPhone should be found in the grid');
        expect(tShirtRowIndex).to.not.equal(-1, 'T-Shirt should be found in the grid');

        const iPhoneRow = getRow(iPhoneRowIndex);
        const tShirtRow = getRow(tShirtRowIndex);

        // Drag iPhone from Electronics to Clothing group (drop above T-Shirt)
        performDragReorder(iPhoneRow, tShirtRow, 'above');

        // Verify groupingValueSetter was called
        expect(groupingValueSetter.callCount).to.equal(1);
        expect(groupingValueSetter.firstCall.args[0]).to.equal('Clothing'); // groupingValue should be 'Clothing'

        // Verify the row passed to the setter matches iPhone data
        const passedRow = groupingValueSetter.firstCall.args[1];
        expect(passedRow.name).to.equal('iPhone');
        expect(passedRow.price).to.equal(999);

        // Verify the row data was updated correctly in dataRowIdToModelLookup
        const updatedRow = apiRef.current!.getRow(1);
        expect(updatedRow.category).to.deep.equal({
          main: 'Clothing',
          sub: 'Phones', // Original sub-category preserved
        });

        // Verify the row moved to the correct group
        const newGroupingValues = getColumnValues(1);
        expect(newGroupingValues).to.include('Electronics (1)'); // One less item
        expect(newGroupingValues).to.include('Clothing (3)'); // One more item
      });
    });
  });

  describe('Multi-level row grouping (2 levels)', () => {
    const baselineProps: DataGridPremiumProps = {
      rows: multiLevelData,
      columns: [
        { field: 'company', width: 150 },
        { field: 'dept', width: 150 },
        { field: 'team', width: 150 },
        { field: 'name', width: 150 },
      ],
      initialState: {
        rowGrouping: {
          model: ['company', 'dept'],
        },
      },
      defaultGroupingExpansionDepth: -1,
      rowReordering: true,
      disableVirtualization: true,
      autoHeight: isJSDOM,
    };

    describe('Valid reorder cases', () => {
      it('should reorder leaves within same department', () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} />
          </div>,
        );

        // Find John and Jane rows (both in Microsoft/Engineering)
        const nameValues = getColumnValues(5);
        const johnIndex = nameValues.indexOf('John');
        const janeIndex = nameValues.indexOf('Jane');

        const johnRow = getRow(johnIndex);
        const janeRow = getRow(janeIndex);

        // Drag John to Jane position (below)
        performDragReorder(johnRow, janeRow, 'below');

        // Verify new order
        const newNameValues = getColumnValues(5);
        const newJohnIndex = newNameValues.indexOf('John');
        const newJaneIndex = newNameValues.indexOf('Jane');

        expect(newJaneIndex).to.be.lessThan(newJohnIndex);
      });

      it('should move leaf between departments in same company', () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} />
          </div>,
        );

        // Find John (Engineering) and Alice (Sales) rows
        const nameValues = getColumnValues(5);
        const johnIndex = nameValues.indexOf('John');
        const aliceIndex = nameValues.indexOf('Alice');

        const johnRow = getRow(johnIndex);
        const aliceRow = getRow(aliceIndex);

        // Drag John to Alice position (above)
        performDragReorder(johnRow, aliceRow, 'above');

        // Verify John is now before Alice in Sales
        const newNameValues = getColumnValues(5);
        const newJohnIndex = newNameValues.indexOf('John');
        const newAliceIndex = newNameValues.indexOf('Alice');
        const bobIndex = newNameValues.indexOf('Bob'); // Should still be in Engineering

        expect(newJohnIndex).to.be.lessThan(newAliceIndex);
        expect(newJohnIndex).to.be.greaterThan(bobIndex);
      });

      it('should reorder department groups within company', () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} />
          </div>,
        );

        // Find Engineering and Sales department groups within Microsoft
        const deptValues = getColumnValues(1);
        const engIndex = deptValues.indexOf('Engineering (3)');
        const salesIndex = deptValues.indexOf('Google (3)');

        const engRow = getRow(engIndex);
        const googleRow = getRow(salesIndex);

        // Drag Engineering to Sales position by dropping above the next group
        performDragReorder(engRow, googleRow, 'above');

        // Verify department order changed
        const newDeptValues = getColumnValues(1);
        const newEngIndex = newDeptValues.indexOf('Engineering (3)');
        const newSalesIndex = newDeptValues.indexOf('Sales (2)');

        expect(newSalesIndex).to.be.lessThan(newEngIndex);
      });

      it('should reorder group rows with collapsed groups', () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium
              {...baselineProps}
              defaultGroupingExpansionDepth={0} // All groups collapsed by default
              isGroupExpandedByDefault={(node: GridGroupNode) => {
                // Expand Microsoft company and its Engineering dept
                if (node.groupingKey === 'Microsoft') {
                  return true;
                }
                if (
                  (node.parent as unknown as GridGroupNode)?.groupingKey === 'Microsoft' &&
                  node.groupingKey === 'Engineering'
                ) {
                  return true;
                }
                return false;
              }}
            />
          </div>,
        );

        // Initial state: Microsoft expanded with Engineering expanded, Google collapsed, Apple collapsed
        const values = getColumnValues(1);

        // Test 1: Reorder collapsed top-level groups (Google and Apple)
        const googleIndex = values.findIndex((v) => v?.includes('Google ('));
        const appleIndex = values.findIndex((v) => v?.includes('Apple ('));

        const googleRow = getRow(googleIndex);
        const appleRow = getRow(appleIndex);

        performDragReorder(googleRow, appleRow, 'below');

        // Verify new order: Microsoft, Apple, Google
        const newValues = getColumnValues(1);
        const newMsIndex = newValues.findIndex((v) => v?.includes('Microsoft ('));
        const newAppleIndex = newValues.findIndex((v) => v?.includes('Apple ('));
        const newGoogleIndex = newValues.findIndex((v) => v?.includes('Google ('));

        expect(newMsIndex).to.be.lessThan(newAppleIndex);
        expect(newAppleIndex).to.be.lessThan(newGoogleIndex);

        // Test 2: Verify the group reordering worked correctly
        const finalValues = getColumnValues(1);
        const finalMsIndex = finalValues.findIndex((v) => v?.includes('Microsoft ('));
        const finalAppleIndex = finalValues.findIndex((v) => v?.includes('Apple ('));
        const finalGoogleIndex = finalValues.findIndex((v) => v?.includes('Google ('));

        // Verify the group order is correct: Microsoft, Apple, Google
        expect(finalMsIndex).to.be.lessThan(finalAppleIndex);
        expect(finalAppleIndex).to.be.lessThan(finalGoogleIndex);
      });

      it('should auto-expand collapsed groups at multiple levels when leaf is dragged over', async () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium
              {...baselineProps}
              defaultGroupingExpansionDepth={0} // All collapsed by default
              isGroupExpandedByDefault={(node: GridGroupNode) => {
                // Expand Microsoft and its Sales dept to have visible leaf rows
                if (node.groupingKey === 'Microsoft') {
                  return true;
                }
                if (
                  (node.parent as unknown as GridGroupNode)?.groupingKey === 'Microsoft' &&
                  node.groupingKey === 'Sales'
                ) {
                  return true;
                }
                return false;
              }}
            />
          </div>,
        );

        const values = getColumnValues(1);
        const googleIndex = values.findIndex((v) => v?.includes('Google ('));
        const googleRow = getRow(googleIndex);

        // Use the first visible row as the source
        const allRows = screen.getAllByRole('row');
        const sourceRow = allRows.find(
          (row) =>
            row.getAttribute('data-id') &&
            !row.querySelector('[data-field="__row_group_by_columns_group__"]'),
        );

        if (sourceRow) {
          const sourceCell = sourceRow.querySelector('[role="gridcell"]')!.firstChild!;
          const targetCell = googleRow.querySelector('[role="gridcell"]')!;

          fireDragStart(sourceCell);
          fireEvent.dragEnter(targetCell);

          // Drag over collapsed Google
          const dragOverEvent = createDragOverEvent(targetCell, 'below');
          fireEvent(targetCell, dragOverEvent);

          // Wait for auto-expand - Google should show its departments
          await waitFor(
            () => {
              const currentValues = getColumnValues(1);
              // Look for any department under Google (Engineering or other)
              const hasExpandedDept = currentValues.some(
                (v, i) => i > googleIndex && (v === 'Engineering (3)' || v === 'Design (2)'),
              );
              expect(hasExpandedDept).to.equal(true);
            },
            { timeout: 1000 },
          );

          // Complete the drag
          const dragEndEvent = createDragEndEvent(sourceCell);
          fireEvent(sourceCell, dragEndEvent);
        }

        const finalValues = getColumnValues(1);
        const finalGoogleIndex = finalValues.findIndex((v) => v?.includes('Google ('));
        expect(finalGoogleIndex).to.not.equal(-1);
      });
    });

    describe('Invalid reorder cases', () => {
      it('should not allow moving groups between different companies', () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} />
          </div>,
        );

        // Find Microsoft/Engineering and Google company groups
        const values = getColumnValues(1);
        const googleIndex = values.indexOf('Google (3)');

        // Get the Engineering dept under Microsoft
        const deptValues = getColumnValues(1);
        const msEngIndex = deptValues.indexOf('Engineering (3)');

        const msEngRow = screen.getAllByRole('row')[msEngIndex + 1];
        const googleRow = screen.getAllByRole('row')[googleIndex + 1];

        // Try to drag MS/Engineering to Google
        performDragReorder(msEngRow, googleRow, 'below');

        // Verify no change - Engineering should still be under Microsoft
        const newDeptValues = getColumnValues(1);
        expect(newDeptValues[msEngIndex]).to.equal('Engineering (3)');
      });

      it('should not allow cross-depth movements', () => {
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} />
          </div>,
        );

        const initialValues = getColumnValues(5);

        // Try to drag company group to leaf position
        const companyValues = getColumnValues(1);
        const msIndex = companyValues.indexOf('Microsoft (5)');
        const nameValues = getColumnValues(5);
        const johnIndex = nameValues.indexOf('John');

        const msRow = getRow(msIndex);
        const johnRow = getRow(johnIndex);

        // Try to drag Microsoft to John position
        performDragReorder(msRow, johnRow, 'above');

        // Verify no change
        const newValues = getColumnValues(5);
        expect(newValues).to.deep.equal(initialValues);
      });
    });

    describe('Usage with `groupingValueSetter`', () => {
      it('should call groupingValueSetter for multiple grouping levels when moving between groups', () => {
        const companyValueSetter = spy((groupingValue, row, _column, _apiRef) => {
          return {
            ...row,
            company: groupingValue,
            // Reset dept to a default when changing companies
            dept: 'Engineering',
          };
        });

        const deptValueSetter = spy((groupingValue, row, _column, _apiRef) => {
          return {
            ...row,
            dept: groupingValue,
            // Reset team to a default when changing departments
            team: 'General',
          };
        });

        const multiLevelProps: DataGridPremiumProps = {
          rows: multiLevelData, // Use existing test data
          columns: [
            {
              field: 'company',
              width: 150,
              groupingValueSetter: companyValueSetter,
            },
            {
              field: 'dept',
              width: 150,
              groupingValueSetter: deptValueSetter,
            },
            { field: 'team', width: 150 },
            { field: 'name', width: 150 },
          ],
          initialState: {
            rowGrouping: {
              model: ['company', 'dept'],
            },
          },
          defaultGroupingExpansionDepth: -1,
          rowReordering: true,
          disableVirtualization: true,
          autoHeight: isJSDOM,
        };

        const apiRef = React.createRef<GridApi>();
        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...multiLevelProps} apiRef={apiRef} />
          </div>,
        );

        // Verify initial setup - John should be under Microsoft -> Engineering
        const initialValues = getColumnValues(1);
        expect(initialValues).to.include('Microsoft (5)');
        expect(initialValues).to.include('Google (3)');
        expect(initialValues).to.include('Apple (2)');

        // Grid structure verified - proceeding with drag operation

        // The names should be in column 5 (name field), but may not be visible in grouped view
        // Instead, let's use a simpler approach: drag the first Microsoft employee to Google
        // Find the first Microsoft employee (row index 2) and first Google employee
        const microsoftEmployeeIndex = 2; // First Microsoft Engineering employee
        const googleEmployeeIndex = 10; // First Google Engineering employee

        const johnRow = getRow(microsoftEmployeeIndex);
        const bobRow = getRow(googleEmployeeIndex);

        // Drag Microsoft employee from Engineering to Google/Engineering (drop above Bob)
        performDragReorder(johnRow, bobRow, 'above');

        // Verify both setters were called in the correct order
        expect(companyValueSetter.callCount).to.equal(1);
        expect(deptValueSetter.callCount).to.equal(1);

        // Verify company setter was called with correct parameters
        expect(companyValueSetter.firstCall.args[0]).to.equal('Google'); // target company
        const companySetterRow = companyValueSetter.firstCall.args[1];
        expect(companySetterRow.company).to.equal('Microsoft'); // Original company
        expect(companySetterRow.dept).to.equal('Engineering'); // Original dept

        // Verify dept setter was called with correct parameters
        expect(deptValueSetter.firstCall.args[0]).to.equal('Engineering'); // target dept (Google has Engineering)
        const deptSetterRow = deptValueSetter.firstCall.args[1];
        expect(deptSetterRow.company).to.equal('Google'); // Already updated by company setter

        // Verify the final row data was updated correctly
        const updatedRow = apiRef.current!.getRow(1); // The first Microsoft employee (John)
        expect(updatedRow.company).to.equal('Google');
        expect(updatedRow.dept).to.equal('Engineering'); // Moved to Google Engineering
        expect(updatedRow.team).to.equal('General'); // Reset by dept setter

        // Verify group counts updated
        const newValues = getColumnValues(1);
        expect(newValues).to.include('Microsoft (4)'); // One less employee (was 5, now 4)
        expect(newValues).to.include('Google (4)'); // One more employee (was 3, now 4)
      });
    });
  });

  describe('Edge cases', () => {
    it('should handle null grouping values', () => {
      render(
        <div style={{ width: 500, height: 500 }}>
          <DataGridPremium
            rows={singleLevelData}
            columns={[
              { field: 'category', width: 150 },
              { field: 'name', width: 150 },
              { field: 'value', width: 100, type: 'number' },
            ]}
            initialState={{
              rowGrouping: {
                model: ['category'],
              },
            }}
            defaultGroupingExpansionDepth={-1}
            rowReordering
            disableVirtualization
            autoHeight={isJSDOM}
          />
        </div>,
      );

      // Find null group items
      const nameValues = getColumnValues(3);
      const null1Index = nameValues.indexOf('Item Null1');
      const null2Index = nameValues.indexOf('Item Null2');

      const null1Row = getRow(null1Index);
      const null2Row = getRow(null2Index);

      // Reorder within null group
      performDragReorder(null1Row, null2Row, 'below');

      // Verify order changed
      const newNameValues = getColumnValues(3);
      const newNull1Index = newNameValues.indexOf('Item Null1');
      const newNull2Index = newNameValues.indexOf('Item Null2');

      expect(newNull2Index).to.be.lessThan(newNull1Index);
    });

    it('should call onRowOrderChange with correct parameters', () => {
      const onRowOrderChange = spy();

      render(
        <div style={{ width: 500, height: 500 }}>
          <DataGridPremium
            rows={singleLevelData}
            columns={[
              { field: 'category', width: 150 },
              { field: 'name', width: 150 },
              { field: 'value', width: 100, type: 'number' },
            ]}
            initialState={{
              rowGrouping: {
                model: ['category'],
              },
            }}
            defaultGroupingExpansionDepth={-1}
            rowReordering
            onRowOrderChange={onRowOrderChange}
            disableVirtualization
            autoHeight={isJSDOM}
          />
        </div>,
      );

      // Reorder within a group
      const itemA1Row = getRow(3);
      const itemA3Row = getRow(5);

      performDragReorder(itemA1Row, itemA3Row, 'below');

      // Verify callback was called
      expect(onRowOrderChange.callCount).to.equal(1);

      const params = onRowOrderChange.firstCall.args[0];
      expect(params.row.id).to.equal(1); // Item A1
      expect(params.oldIndex).to.be.a('number');
      expect(params.targetIndex).to.be.a('number');
      expect(params.oldIndex).to.not.equal(params.targetIndex);
    });

    describe('processRowUpdate integration', () => {
      const baselineProps: DataGridPremiumProps = {
        rows: singleLevelData,
        columns: [
          { field: 'category', width: 150 },
          { field: 'name', width: 150 },
          { field: 'value', width: 100, type: 'number' },
        ],
        initialState: {
          rowGrouping: {
            model: ['category'],
          },
        },
        defaultGroupingExpansionDepth: -1,
        rowReordering: true,
        disableVirtualization: true,
        autoHeight: isJSDOM,
      };

      it('should call processRowUpdate when reordering between different parent groups', async () => {
        const processRowUpdate = spy((newRow, _oldRow, _params) => ({
          ...newRow,
          category: newRow.category, // Preserve the new category from grouping rules
        }));

        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} processRowUpdate={processRowUpdate} />
          </div>,
        );

        // Move Item A1 (id: 1) from category A to category B
        const itemA1Row = getRow(3);
        const itemB1Row = getRow(7);

        performDragReorder(itemA1Row, itemB1Row, 'above');

        // Wait for async processRowUpdate to complete
        await waitFor(() => {
          expect(processRowUpdate.callCount).to.equal(1);
        });

        // Verify processRowUpdate was called with correct parameters
        const args = processRowUpdate.firstCall.args;
        expect(args.length).to.equal(3);
        const [newRow, oldRow, params] = args;
        expect(newRow.id).to.equal(1);
        expect(newRow.category).to.equal('B'); // Should be updated by grouping rules
        expect(oldRow.id).to.equal(1);
        expect(oldRow.category).to.equal('A');
        expect(params.rowId).to.equal(1);
      });

      it('should handle processRowUpdate returning modified data', async () => {
        const processRowUpdate = spy((newRow, _oldRow, _params) => ({
          ...newRow,
          name: `${newRow.name} (Modified)`,
        }));

        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} processRowUpdate={processRowUpdate} />
          </div>,
        );

        // Move Item A1 from category A to category B
        const itemA1Row = getRow(3);
        const itemB1Row = getRow(7);

        performDragReorder(itemA1Row, itemB1Row, 'above');

        await waitFor(() => {
          expect(processRowUpdate.callCount).to.equal(1);
        });

        // Verify the modified name is displayed in the grid
        await waitFor(() => {
          const nameValues = getColumnValues(3);
          expect(nameValues).to.include('Item A1 (Modified)');
        });
      });

      it('should handle processRowUpdate returning a Promise', async () => {
        const processRowUpdate = spy(async (newRow, _oldRow, _params) => {
          // Simulate async operation
          await new Promise<void>((resolve) => {
            setTimeout(resolve, 10);
          });
          return {
            ...newRow,
            name: `${newRow.name} (Async)`,
          };
        });

        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} processRowUpdate={processRowUpdate} />
          </div>,
        );

        const itemA1Row = getRow(3);
        const itemB1Row = getRow(7);

        performDragReorder(itemA1Row, itemB1Row, 'above');

        await waitFor(() => {
          expect(processRowUpdate.callCount).to.equal(1);
        });

        // Verify async result is applied
        await waitFor(() => {
          const nameValues = getColumnValues(3);
          expect(nameValues).to.include('Item A1 (Async)');
        });
      });

      it('should call onProcessRowUpdateError when processRowUpdate throws an error', async () => {
        const processRowUpdate = spy((_newRow, _oldRow, _params) => {
          throw new Error('Validation failed');
        });
        const onProcessRowUpdateError = spy();

        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium
              {...baselineProps}
              processRowUpdate={processRowUpdate}
              onProcessRowUpdateError={onProcessRowUpdateError}
            />
          </div>,
        );

        const itemA1Row = getRow(3);
        const itemB1Row = getRow(7);

        performDragReorder(itemA1Row, itemB1Row, 'above');

        await waitFor(() => {
          expect(processRowUpdate.callCount).to.equal(1);
        });

        await waitFor(() => {
          expect(onProcessRowUpdateError.callCount).to.equal(1);
        });

        // Verify error was passed to handler
        const error = onProcessRowUpdateError.firstCall.args[0];
        expect(error.message).to.equal('Validation failed');

        // Verify row order was not changed due to error
        const nameValues = getColumnValues(3);
        const a1Index = nameValues.indexOf('Item A1');
        const b1Index = nameValues.indexOf('Item B1');
        // A1 should still be in category A (before B1)
        expect(a1Index).to.be.lessThan(b1Index);
      });

      it('should call onProcessRowUpdateError when processRowUpdate Promise rejects', async () => {
        const processRowUpdate = spy(async (_newRow, _oldRow, _params) => {
          throw new Error('Async validation failed');
        });
        const onProcessRowUpdateError = spy();

        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium
              {...baselineProps}
              processRowUpdate={processRowUpdate}
              onProcessRowUpdateError={onProcessRowUpdateError}
            />
          </div>,
        );

        const itemA1Row = getRow(3);
        const itemB1Row = getRow(7);

        performDragReorder(itemA1Row, itemB1Row, 'above');

        await waitFor(() => {
          expect(processRowUpdate.callCount).to.equal(1);
        });

        await waitFor(() => {
          expect(onProcessRowUpdateError.callCount).to.equal(1);
        });

        // Verify error was passed to handler
        const error = onProcessRowUpdateError.firstCall.args[0];
        expect(error.message).to.equal('Async validation failed');
      });

      it('should not call processRowUpdate when reordering within same parent group', () => {
        const processRowUpdate = spy();

        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium {...baselineProps} processRowUpdate={processRowUpdate} />
          </div>,
        );

        // Reorder within same category (A1 to A3 position)
        const itemA1Row = getRow(3);
        const itemA3Row = getRow(5);

        performDragReorder(itemA1Row, itemA3Row, 'below');

        // processRowUpdate should not be called for same-parent reorders
        expect(processRowUpdate.callCount).to.equal(0);
      });
    });

    describe('dataSource.editRow integration', () => {
      const baselineProps: DataGridPremiumProps = {
        columns: [
          { field: 'category', width: 150 },
          { field: 'name', width: 150 },
          { field: 'value', width: 100, type: 'number' },
        ],
        initialState: {
          rowGrouping: {
            model: ['category'],
          },
        },
        defaultGroupingExpansionDepth: -1,
        rowReordering: true,
        disableVirtualization: true,
        autoHeight: isJSDOM,
      };

      it('should call dataSource.editRow when reordering between different parent groups', async () => {
        const editRowSpy = spy();
        const getRowsSpy = spy();
        const dataSource: GridDataSource = {
          getRows: async (params) => {
            getRowsSpy(params);
            if (!params.groupKeys || params.groupKeys.length === 0) {
              // Return top-level groups
              return getRowGroupingDataBasedOnCategory([]);
            }
            // Return children of a specific group
            return getRowGroupingDataBasedOnCategory(params.groupKeys);
          },
          updateRow: async (params) => {
            editRowSpy(params);
            return params.updatedRow;
          },
          getGroupKey: (row) => row.id,
          getChildrenCount: (row) => {
            if (row.group) {
              // This is a group row
              return row.childrenCount || 0;
            }
            return 0;
          },
        };

        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium
              {...baselineProps}
              dataSource={dataSource}
              onDataSourceError={() => {}}
            />
          </div>,
        );

        await waitFor(() => {
          expect(getRowsSpy.callCount).to.equal(5);
        });

        await waitFor(() => {
          // Fetch some child rows
          const allRows = screen.queryAllByRole('row');
          expect(allRows.length).to.be.greaterThan(4);
        });

        await waitFor(() => {
          expect(screen.getByText('Item C1')).toBeVisible();
        });

        // Find rows by their content since row indices might be different with dataSource
        const nameValues = getColumnValues(3);
        const itemA1Index = nameValues.indexOf('Item A1');
        const itemB1Index = nameValues.indexOf('Item B1');

        expect(itemA1Index).to.not.equal(-1, 'Item A1 should be found');
        expect(itemB1Index).to.not.equal(-1, 'Item B1 should be found');

        const itemA1Row = getRow(itemA1Index);
        const itemB1Row = getRow(itemB1Index);

        performDragReorder(itemA1Row, itemB1Row, 'above');

        await waitFor(() => {
          expect(editRowSpy.callCount).to.equal(1);
        });

        // Verify correct parameters were passed
        const params = editRowSpy.firstCall.args[0];
        expect(params.rowId).to.equal(1);
        expect(params.previousRow.id).to.equal(1);
        expect(params.previousRow.category).to.equal('A');
        expect(params.updatedRow.id).to.equal(1);
        expect(params.updatedRow.category).to.equal('B');
      });

      it('should not call dataSource.editRow when reordering within same parent group', async () => {
        const editRowSpy = spy();
        const getRowsSpy = spy();
        const dataSource: GridDataSource = {
          getRows: async (params) => {
            getRowsSpy(params);
            if (!params.groupKeys || params.groupKeys.length === 0) {
              // Return top-level groups
              return getRowGroupingDataBasedOnCategory([]);
            }
            // Return children of a specific group
            return getRowGroupingDataBasedOnCategory(params.groupKeys);
          },
          updateRow: async (params) => {
            editRowSpy(params);
            return params.updatedRow;
          },
          getGroupKey: (row) => row.id,
          getChildrenCount: (row) => {
            if (row.group) {
              // This is a group row
              return row.childrenCount || 0;
            }
            return 0;
          },
        };

        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium
              {...baselineProps}
              dataSource={dataSource}
              onDataSourceError={() => {}}
            />
          </div>,
        );

        await waitFor(() => {
          expect(getRowsSpy.callCount).to.equal(5);
        });

        await waitFor(() => {
          // Fetch some child rows
          const allRows = screen.queryAllByRole('row');
          expect(allRows.length).to.be.greaterThan(4);
        });

        await waitFor(() => {
          expect(screen.getByText('Item C1')).toBeVisible();
        });

        // Find rows by their content since row indices might be different with dataSource
        const nameValues = getColumnValues(3);
        const itemB1Index = nameValues.indexOf('Item B1');
        const itemB2Index = nameValues.indexOf('Item B2');

        expect(itemB1Index).to.not.equal(-1, 'Item B1 should be found');
        expect(itemB2Index).to.not.equal(-1, 'Item B2 should be found');

        expect(itemB1Index).to.be.lessThan(itemB2Index);

        const itemB1Row = getRow(itemB1Index);
        const itemB2Row = getRow(itemB2Index);

        performDragReorder(itemB1Row, itemB2Row, 'below');

        const newNameValues = getColumnValues(3);

        expect(newNameValues.indexOf('Item B1')).to.be.greaterThan(
          newNameValues.indexOf('Item B2'),
        );

        // Wait to ensure no async calls are made
        await act(async () => {
          await new Promise<void>((resolve) => {
            setTimeout(resolve, 50);
          });
        });

        // Should not call editRow since group hasn't changed
        expect(editRowSpy.callCount).to.equal(0);
      });

      it('should call dataSource.setGroupKey when available instead of direct field assignment', async () => {
        const editRowSpy = spy();
        const getRowsSpy = spy();
        const setGroupKeySpy = spy((row, groupKey) => {
          const split = groupKey.split('-');
          const category = split[split.length - 1];
          return {
            ...row,
            category,
          };
        });

        const dataSource = {
          getRows: async (params) => {
            getRowsSpy(params);
            if (!params.groupKeys || params.groupKeys.length === 0) {
              // Return top-level groups
              return getRowGroupingDataBasedOnCategory([]);
            }
            // Return children of a specific group
            return getRowGroupingDataBasedOnCategory(params.groupKeys);
          },
          updateRow: async (params) => {
            editRowSpy(params);
            return params.updatedRow;
          },
          getGroupKey: (row) => row.id,
          setGroupKey: setGroupKeySpy,
          getChildrenCount: (row) => {
            if (row.group) {
              // This is a group row
              return row.childrenCount || 0;
            }
            return 0;
          },
        } as GridDataSource;

        render(
          <div style={{ width: 500, height: 500 }}>
            <DataGridPremium
              {...baselineProps}
              dataSource={dataSource}
              onDataSourceError={() => {}}
            />
          </div>,
        );

        await waitFor(() => {
          expect(getRowsSpy.callCount).to.equal(5);
        });

        await waitFor(() => {
          // Fetch some child rows
          const allRows = screen.queryAllByRole('row');
          expect(allRows.length).to.be.greaterThan(4);
        });

        await waitFor(() => {
          expect(screen.getByText('Item C1')).toBeVisible();
        });

        // Find rows by their content
        const nameValues = getColumnValues(3);
        const itemA1Index = nameValues.indexOf('Item A1');
        const itemB1Index = nameValues.indexOf('Item B1');

        expect(itemA1Index).to.not.equal(-1, 'Item A1 should be found');
        expect(itemB1Index).to.not.equal(-1, 'Item B1 should be found');

        const itemA1Row = getRow(itemA1Index);
        const itemB1Row = getRow(itemB1Index);

        // Move Item A1 from category A to category B
        performDragReorder(itemA1Row, itemB1Row, 'above');

        await waitFor(() => {
          expect(setGroupKeySpy.callCount).to.equal(1);
        });

        // Verify `setGroupKey()` was called with correct parameters
        expect(setGroupKeySpy.firstCall.args[0]).to.deep.include({
          id: 1,
          category: 'A',
          name: 'Item A1',
          value: 10,
        });
        expect(setGroupKeySpy.firstCall.args[1]).to.equal('autogenerated-parent-category-B'); // Group key of the target row's parent group

        await waitFor(() => {
          expect(editRowSpy.callCount).to.equal(1);
        });

        // Verify updateRow was called with the result from `setGroupKey()`
        const updateRowParams = editRowSpy.firstCall.args[0];
        expect(updateRowParams.updatedRow).to.deep.include({
          id: 1,
          category: 'B',
          name: 'Item A1',
          value: 10,
        });
      });
    });
  });
});
