"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAggregationLookup = exports.shouldApplySorting = void 0;
var x_data_grid_pro_1 = require("@mui/x-data-grid-pro");
var internals_1 = require("@mui/x-data-grid/internals");
var shouldApplySorting = function (aggregationRules, aggregatedFields) {
    return aggregatedFields.some(function (field) { return aggregationRules[field].aggregationFunction.applySorting; });
};
exports.shouldApplySorting = shouldApplySorting;
var getGroupAggregatedValue = function (groupId, apiRef, aggregationRowsScope, aggregatedFields, aggregationRules, position, applySorting, valueGetters, publicApi, groupAggregatedValuesLookup) {
    var groupAggregationLookup = {};
    var aggregatedValues = [];
    for (var i = 0; i < aggregatedFields.length; i += 1) {
        aggregatedValues[i] = {
            aggregatedField: aggregatedFields[i],
            values: [],
        };
    }
    var rowTree = (0, x_data_grid_pro_1.gridRowTreeSelector)(apiRef);
    var rowLookup = (0, x_data_grid_pro_1.gridRowsLookupSelector)(apiRef);
    var isPivotActive = apiRef.current.state.pivoting.active;
    var rowIds = apiRef.current.getRowGroupChildren({
        groupId: groupId,
        applySorting: applySorting,
        directChildrenOnly: true,
        skipAutoGeneratedRows: false,
        applyFiltering: aggregationRowsScope === 'filtered',
    });
    for (var i = 0; i < rowIds.length; i += 1) {
        var rowId = rowIds[i];
        var rowNode = rowTree[rowId];
        if (rowNode.type === 'group') {
            // MERGE EXISTING VALUES FROM THE LOOKUP TABLE
            var childGroupValues = groupAggregatedValuesLookup.get(rowId);
            if (childGroupValues) {
                for (var j = 0; j < aggregatedFields.length; j += 1) {
                    aggregatedValues[j].values = aggregatedValues[j].values.concat(childGroupValues[j].values);
                }
            }
            continue;
        }
        var row = rowLookup[rowId];
        for (var j = 0; j < aggregatedFields.length; j += 1) {
            var aggregatedField = aggregatedFields[j];
            var columnAggregationRules = aggregationRules[aggregatedField];
            var aggregationFunction = columnAggregationRules.aggregationFunction;
            var field = aggregatedField;
            var value = void 0;
            if (typeof aggregationFunction.getCellValue === 'function') {
                value = aggregationFunction.getCellValue({ field: field, row: row });
            }
            else if (isPivotActive) {
                // Since we know that pivoted fields are flat, we can use the row directly, and save lots of processing time
                value = row[field];
            }
            else {
                if (!row) {
                    continue;
                }
                var valueGetter = valueGetters[aggregatedField];
                value = valueGetter(row);
            }
            if (value !== undefined) {
                aggregatedValues[j].values.push(value);
            }
        }
    }
    for (var i = 0; i < aggregatedValues.length; i += 1) {
        var _a = aggregatedValues[i], aggregatedField = _a.aggregatedField, values = _a.values;
        var aggregationFunction = aggregationRules[aggregatedField]
            .aggregationFunction;
        var value = aggregationFunction.apply({
            values: values,
            groupId: groupId,
            field: aggregatedField, // Added per user request in https://github.com/mui/mui-x/issues/6995#issuecomment-1327423455
        }, publicApi);
        groupAggregationLookup[aggregatedField] = {
            position: position,
            value: value,
        };
    }
    return { groupAggregationLookup: groupAggregationLookup, aggregatedValues: aggregatedValues };
};
var getGroupAggregatedValueDataSource = function (groupId, apiRef, aggregatedFields, position) {
    var _a, _b, _c;
    var groupAggregationLookup = {};
    for (var j = 0; j < aggregatedFields.length; j += 1) {
        var aggregatedField = aggregatedFields[j];
        groupAggregationLookup[aggregatedField] = {
            position: position,
            value: (_c = (_b = (_a = apiRef.current).resolveGroupAggregation) === null || _b === void 0 ? void 0 : _b.call(_a, groupId, aggregatedField)) !== null && _c !== void 0 ? _c : '',
        };
    }
    return groupAggregationLookup;
};
var createAggregationLookup = function (_a) {
    var apiRef = _a.apiRef, aggregationRules = _a.aggregationRules, aggregatedFields = _a.aggregatedFields, aggregationRowsScope = _a.aggregationRowsScope, getAggregationPosition = _a.getAggregationPosition, isDataSource = _a.isDataSource, _b = _a.applySorting, applySorting = _b === void 0 ? false : _b;
    if (aggregatedFields.length === 0) {
        return {};
    }
    var columnsLookup = (0, x_data_grid_pro_1.gridColumnLookupSelector)(apiRef);
    var valueGetters = {};
    var _loop_1 = function (i) {
        var field = aggregatedFields[i];
        var column = columnsLookup[field];
        var valueGetter = function (row) { return apiRef.current.getRowValue(row, column); };
        valueGetters[field] = valueGetter;
    };
    for (var i = 0; i < aggregatedFields.length; i += 1) {
        _loop_1(i);
    }
    var aggregationLookup = {};
    var rowTree = (0, x_data_grid_pro_1.gridRowTreeSelector)(apiRef);
    var groupAggregatedValuesLookup = new Map();
    var rowIdToIndexMap = (0, internals_1.getVisibleRows)(apiRef).rowIdToIndexMap;
    var createGroupAggregationLookup = function (groupNode) {
        var children = groupNode.children;
        if (applySorting) {
            children = children.toSorted(function (a, b) { return rowIdToIndexMap.get(a) - rowIdToIndexMap.get(b); });
        }
        for (var i = 0; i < children.length; i += 1) {
            var childId = children[i];
            var childNode = rowTree[childId];
            if (childNode.type === 'group') {
                createGroupAggregationLookup(childNode);
            }
        }
        var position = getAggregationPosition(groupNode);
        if (position !== null) {
            if (isDataSource) {
                aggregationLookup[groupNode.id] = getGroupAggregatedValueDataSource(groupNode.id, apiRef, aggregatedFields, position);
            }
            else if (groupNode.children.length) {
                var result = getGroupAggregatedValue(groupNode.id, apiRef, aggregationRowsScope, aggregatedFields, aggregationRules, position, applySorting, valueGetters, apiRef.current, groupAggregatedValuesLookup);
                aggregationLookup[groupNode.id] = result.groupAggregationLookup;
                groupAggregatedValuesLookup.set(groupNode.id, result.aggregatedValues);
            }
        }
    };
    createGroupAggregationLookup(rowTree[x_data_grid_pro_1.GRID_ROOT_GROUP_ID]);
    return aggregationLookup;
};
exports.createAggregationLookup = createAggregationLookup;
