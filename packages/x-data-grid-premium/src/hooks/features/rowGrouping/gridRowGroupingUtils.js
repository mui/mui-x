"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.areGroupingRulesEqual = exports.getGroupingRules = exports.getCellGroupingCriteria = exports.setStrategyAvailability = exports.mergeStateWithRowGroupingModel = exports.getColDefOverrides = exports.filterRowTreeFromGroupingColumns = exports.getRowGroupingFieldFromGroupingCriteria = exports.isGroupingColumn = exports.getRowGroupingCriteriaFromGroupingField = exports.GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD = void 0;
var internals_1 = require("@mui/x-data-grid-pro/internals");
Object.defineProperty(exports, "GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD", { enumerable: true, get: function () { return internals_1.GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD; } });
Object.defineProperty(exports, "getRowGroupingCriteriaFromGroupingField", { enumerable: true, get: function () { return internals_1.getRowGroupingCriteriaFromGroupingField; } });
Object.defineProperty(exports, "isGroupingColumn", { enumerable: true, get: function () { return internals_1.isGroupingColumn; } });
var gridRowGroupingSelector_1 = require("./gridRowGroupingSelector");
var getRowGroupingFieldFromGroupingCriteria = function (groupingCriteria) {
    if (groupingCriteria === null) {
        return internals_1.GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD;
    }
    return "__row_group_by_columns_group_".concat(groupingCriteria, "__");
};
exports.getRowGroupingFieldFromGroupingCriteria = getRowGroupingFieldFromGroupingCriteria;
/**
 * When filtering a group, we only want to filter according to the items related to this grouping column.
 */
var shouldApplyFilterItemOnGroup = function (columnField, node) {
    if (columnField === internals_1.GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD) {
        return true;
    }
    var groupingCriteriaField = (0, internals_1.getRowGroupingCriteriaFromGroupingField)(columnField);
    return groupingCriteriaField === node.groupingField;
};
/**
 * A leaf is visible if it passed the filter
 * A group is visible if all the following criteria are met:
 * - One of its children is passing the filter
 * - It is passing the filter
 */
var filterRowTreeFromGroupingColumns = function (params) {
    var apiRef = params.apiRef, rowTree = params.rowTree, isRowMatchingFilters = params.isRowMatchingFilters, filterModel = params.filterModel;
    var filteredRowsLookup = {};
    var filteredChildrenCountLookup = {};
    var filteredDescendantCountLookup = {};
    var filterCache = {};
    var filterTreeNode = function (node, areAncestorsExpanded, ancestorsResults) {
        var filterResults = {
            passingFilterItems: null,
            passingQuickFilterValues: null,
        };
        var isPassingFiltering = false;
        if (isRowMatchingFilters && node.type !== 'footer') {
            var shouldApplyItem = node.type === 'group' && node.isAutoGenerated
                ? function (columnField) { return shouldApplyFilterItemOnGroup(columnField, node); }
                : undefined;
            var row = apiRef.current.getRow(node.id);
            isRowMatchingFilters(row, shouldApplyItem, filterResults);
        }
        else {
            isPassingFiltering = true;
        }
        var filteredChildrenCount = 0;
        var filteredDescendantCount = 0;
        if (node.type === 'group') {
            node.children.forEach(function (childId) {
                var childNode = rowTree[childId];
                var childSubTreeSize = filterTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded, __spreadArray(__spreadArray([], ancestorsResults, true), [filterResults], false));
                filteredDescendantCount += childSubTreeSize;
                if (childSubTreeSize > 0) {
                    filteredChildrenCount += 1;
                }
            });
        }
        if (isPassingFiltering === false) {
            if (node.type === 'group') {
                // If node has children - it's passing if at least one child passes filters
                isPassingFiltering = filteredDescendantCount > 0;
            }
            else {
                var allResults = __spreadArray(__spreadArray([], ancestorsResults, true), [filterResults], false);
                isPassingFiltering = (0, internals_1.passFilterLogic)(allResults.map(function (result) { return result.passingFilterItems; }), allResults.map(function (result) { return result.passingQuickFilterValues; }), filterModel, params.apiRef, filterCache);
            }
        }
        if (!isPassingFiltering) {
            filteredRowsLookup[node.id] = false;
        }
        if (!isPassingFiltering) {
            return 0;
        }
        filteredChildrenCountLookup[node.id] = filteredChildrenCount;
        filteredDescendantCountLookup[node.id] = filteredDescendantCount;
        if (node.type !== 'group') {
            return filteredDescendantCount + 1;
        }
        return filteredDescendantCount;
    };
    var nodes = Object.values(rowTree);
    for (var i = 0; i < nodes.length; i += 1) {
        var node = nodes[i];
        if (node.depth === 0) {
            filterTreeNode(node, true, []);
        }
    }
    return {
        filteredRowsLookup: filteredRowsLookup,
        filteredChildrenCountLookup: filteredChildrenCountLookup,
        filteredDescendantCountLookup: filteredDescendantCountLookup,
    };
};
exports.filterRowTreeFromGroupingColumns = filterRowTreeFromGroupingColumns;
var getColDefOverrides = function (groupingColDefProp, fields, strategy) {
    if (typeof groupingColDefProp === 'function') {
        return groupingColDefProp({
            groupingName: strategy !== null && strategy !== void 0 ? strategy : internals_1.RowGroupingStrategy.Default,
            fields: fields,
        });
    }
    return groupingColDefProp;
};
exports.getColDefOverrides = getColDefOverrides;
var mergeStateWithRowGroupingModel = function (rowGroupingModel) {
    return function (state) { return (__assign(__assign({}, state), { rowGrouping: __assign(__assign({}, state.rowGrouping), { model: rowGroupingModel }) })); };
};
exports.mergeStateWithRowGroupingModel = mergeStateWithRowGroupingModel;
var setStrategyAvailability = function (privateApiRef, disableRowGrouping, dataSource) {
    var strategy = dataSource ? internals_1.RowGroupingStrategy.DataSource : internals_1.RowGroupingStrategy.Default;
    if (privateApiRef.current.getActiveStrategy(internals_1.GridStrategyGroup.RowTree) === strategy) {
        // If the strategy is already active, we don't need to set it again
        return;
    }
    var isAvailable;
    if (disableRowGrouping) {
        isAvailable = function () { return false; };
    }
    else {
        isAvailable = function () {
            var rowGroupingSanitizedModel = (0, gridRowGroupingSelector_1.gridRowGroupingSanitizedModelSelector)(privateApiRef);
            return rowGroupingSanitizedModel.length > 0;
        };
    }
    privateApiRef.current.setStrategyAvailability(internals_1.GridStrategyGroup.RowTree, strategy, isAvailable);
};
exports.setStrategyAvailability = setStrategyAvailability;
var getCellGroupingCriteria = function (_a) {
    var row = _a.row, colDef = _a.colDef, groupingRule = _a.groupingRule, apiRef = _a.apiRef;
    var key;
    if (groupingRule.groupingValueGetter) {
        key = groupingRule.groupingValueGetter(row[groupingRule.field], row, colDef, apiRef);
    }
    else {
        key = (0, internals_1.getRowValue)(row, colDef, apiRef);
    }
    return {
        key: key,
        field: groupingRule.field,
    };
};
exports.getCellGroupingCriteria = getCellGroupingCriteria;
var getGroupingRules = function (_a) {
    var sanitizedRowGroupingModel = _a.sanitizedRowGroupingModel, columnsLookup = _a.columnsLookup;
    return sanitizedRowGroupingModel.map(function (field) {
        var _a;
        return ({
            field: field,
            groupingValueGetter: (_a = columnsLookup[field]) === null || _a === void 0 ? void 0 : _a.groupingValueGetter,
        });
    });
};
exports.getGroupingRules = getGroupingRules;
/**
 * Compares two sets of grouping rules to determine if they are equal or not.
 */
var areGroupingRulesEqual = function (newValue, previousValue) {
    if (previousValue.length !== newValue.length) {
        return false;
    }
    return newValue.every(function (newRule, newRuleIndex) {
        var previousRule = previousValue[newRuleIndex];
        if (previousRule.groupingValueGetter !== newRule.groupingValueGetter) {
            return false;
        }
        if (previousRule.field !== newRule.field) {
            return false;
        }
        return true;
    });
};
exports.areGroupingRulesEqual = areGroupingRulesEqual;
