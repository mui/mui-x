import * as React from 'react';
import {
  GridRowId,
  GridGroupNode,
  gridRowTreeSelector,
  gridRowNodeSelector,
  gridExpandedSortedRowIdsSelector,
  GridLeafNode,
  gridRowsLookupSelector,
  gridColumnLookupSelector,
  GridUpdateRowParams,
  GridValidRowModel,
  GridRowTreeConfig,
  GRID_ROOT_GROUP_ID,
} from '@mui/x-data-grid-pro';
import {
  insertNodeInTree,
  removeNodeFromTree,
  GridTreeDepths,
  RowTreeBuilderGroupingCriterion,
} from '@mui/x-data-grid-pro/internals';
import { RefObject } from '@mui/x-internals/types';
import { warnOnce } from '@mui/x-internals/warning';
import { isDeepEqual } from '@mui/x-internals/isDeepEqual';
import { GridPrivateApiPremium } from '../../../models/gridApiPremium';
import { gridRowGroupingSanitizedModelSelector } from '../rowGrouping';
import { getGroupingRules, getCellGroupingCriteria } from '../rowGrouping/gridRowGroupingUtils';
import { DataGridPremiumProcessedProps } from '../../../models/dataGridPremiumProps';

// Get group row ID from path
const getGroupRowIdFromPath = (path: RowTreeBuilderGroupingCriterion[]) => {
  const pathStr = path
    .map((groupingCriteria) => `${groupingCriteria.field}/${groupingCriteria.key}`)
    .join('-');

  return `auto-generated-row-${pathStr}`;
};

// Get the path from a node to the root in the tree
const getNodePathInTree = ({
  id,
  tree,
}: {
  id: GridRowId;
  tree: GridRowTreeConfig;
}): RowTreeBuilderGroupingCriterion[] => {
  const path: RowTreeBuilderGroupingCriterion[] = [];
  let node = tree[id] as GridGroupNode | GridLeafNode;

  while (node.id !== GRID_ROOT_GROUP_ID) {
    path.push({
      field: node.type === 'leaf' ? null : node.groupingField,
      key: node.groupingKey,
    });

    node = tree[node.parent!] as GridGroupNode | GridLeafNode;
  }

  path.reverse();

  return path;
};

// Recursively collect all leaf node IDs from a group
const collectAllLeafDescendants = (
  groupNode: GridGroupNode,
  tree: GridRowTreeConfig,
): GridRowId[] => {
  const leafIds: GridRowId[] = [];

  const collectFromNode = (nodeId: GridRowId) => {
    const node = tree[nodeId];
    if (node.type === 'leaf') {
      leafIds.push(nodeId);
    } else if (node.type === 'group') {
      (node as GridGroupNode).children.forEach(collectFromNode);
    }
  };

  groupNode.children.forEach(collectFromNode);
  return leafIds;
};

// Get or create a group under a parent with specific grouping key/field
const getOrCreateGroupUnderParent = (
  parentId: GridRowId,
  groupingKey: string | number | null,
  groupingField: string | null,
  tree: GridRowTreeConfig,
  treeDepths: GridTreeDepths,
): GridRowId => {
  const parentNode = tree[parentId] as GridGroupNode;
  const fieldName = groupingField ?? '__no_field__';
  const keyName = groupingKey ?? '__no_key__';

  // Check if group already exists
  const existingGroupId = parentNode.childrenFromPath?.[fieldName]?.[keyName.toString()];
  if (existingGroupId && tree[existingGroupId]?.type === 'group') {
    return existingGroupId;
  }

  // Create new group
  const newGroupId = getGroupRowIdFromPath([
    ...getNodePathInTree({ id: parentId, tree }),
    { field: groupingField, key: groupingKey },
  ]);

  const newGroup: GridGroupNode = {
    id: newGroupId,
    type: 'group',
    parent: parentId,
    depth: parentNode.depth + 1,
    groupingKey,
    groupingField,
    children: [],
    childrenFromPath: {},
    childrenExpanded: true,
    isAutoGenerated: true,
  };

  insertNodeInTree(newGroup, tree, treeDepths, null);
  return newGroupId;
};

// Check if a group contains any of the specified row IDs in its descendants
const containsAnyRowIds = (
  groupNode: GridGroupNode,
  rowIds: GridRowId[],
  tree: GridRowTreeConfig,
): boolean => {
  for (const childId of groupNode.children) {
    const childNode = tree[childId];
    if (childNode.type === 'leaf' && rowIds.includes(childId)) {
      return true;
    }
    if (childNode.type === 'group' && containsAnyRowIds(childNode as GridGroupNode, rowIds, tree)) {
      return true;
    }
  }
  return false;
};

// Class to handle updates with partial failure tracking
class GroupMoveRowUpdater {
  private rowsToUpdate = new Map<GridRowId, GridValidRowModel>();

  private originalRows = new Map<GridRowId, GridValidRowModel>();

  private successfulRowIds = new Set<GridRowId>();

  private failedRowIds = new Set<GridRowId>();

  private pendingRowUpdates: GridValidRowModel[] = [];

  constructor(
    private processRowUpdate: DataGridPremiumProcessedProps['processRowUpdate'] | undefined,
    private onProcessRowUpdateError:
      | DataGridPremiumProcessedProps['onProcessRowUpdateError']
      | undefined,
  ) {}

  queueRowUpdate(rowId: GridRowId, originalRow: GridValidRowModel, updatedRow: GridValidRowModel) {
    this.originalRows.set(rowId, originalRow);
    this.rowsToUpdate.set(rowId, updatedRow);
  }

  async executeUpdates(): Promise<{
    successful: GridRowId[];
    failed: GridRowId[];
    updates: GridValidRowModel[];
  }> {
    const rowIds = Array.from(this.rowsToUpdate.keys());

    if (rowIds.length === 0) {
      return { successful: [], failed: [], updates: [] };
    }

    // Handle each row update, tracking success/failure
    const handleRowUpdate = async (rowId: GridRowId) => {
      const newRow = this.rowsToUpdate.get(rowId)!;
      const oldRow = this.originalRows.get(rowId)!;

      try {
        if (typeof this.processRowUpdate === 'function') {
          const params: GridUpdateRowParams = {
            rowId,
            previousRow: oldRow,
            updatedRow: newRow,
          };
          const finalRow = await this.processRowUpdate(newRow, oldRow, params);
          this.pendingRowUpdates.push(finalRow || newRow);
          this.successfulRowIds.add(rowId);
        } else {
          this.pendingRowUpdates.push(newRow);
          this.successfulRowIds.add(rowId);
        }
      } catch (error) {
        this.failedRowIds.add(rowId);
        if (this.onProcessRowUpdateError) {
          this.onProcessRowUpdateError(error);
        } else if (process.env.NODE_ENV !== 'production') {
          console.error('Row update failed:', error);
        }
      }
    };

    // Use Promise.all with wrapped promises to avoid Promise.allSettled (browser support)
    // This pattern is taken from the clipboard import implementation
    const promises = rowIds.map((rowId) => {
      return new Promise<void>((resolve) => {
        handleRowUpdate(rowId).then(resolve).catch(resolve);
      });
    });

    await Promise.all(promises);

    return {
      successful: Array.from(this.successfulRowIds),
      failed: Array.from(this.failedRowIds),
      updates: this.pendingRowUpdates,
    };
  }
}

export const useGridRowsOverridableMethods = (
  apiRef: RefObject<GridPrivateApiPremium>,
  props: Pick<DataGridPremiumProcessedProps, 'processRowUpdate' | 'onProcessRowUpdateError'>,
) => {
  const { processRowUpdate, onProcessRowUpdateError } = props;

  const setRowIndex = React.useCallback(
    (sourceRowId: GridRowId, targetOriginalIndex: number) => {
      const sourceNode = gridRowNodeSelector(apiRef, sourceRowId);
      const sortedFilteredRowIds = gridExpandedSortedRowIdsSelector(apiRef);
      let targetNode = gridRowNodeSelector(apiRef, sortedFilteredRowIds[targetOriginalIndex]);

      if (!sourceNode) {
        throw new Error(`MUI X: No row with id #${sourceRowId} found.`);
      }

      if (!targetNode) {
        throw new Error(`MUI X: No row at index '${targetOriginalIndex}' found.`);
      }

      if (sourceNode.type === 'footer') {
        throw new Error(`MUI X: The row reordering do not support reordering of footer rows.`);
      }

      /**
       * Row Grouping Reordering Use Cases
       * =================================
       *
       * | Case | Source Node | Target Node | Parent Relationship       | Action                                                                      |
       * | :--- | :---------- | :---------- | :------------------------ | :-------------------------------------------------------------------------- |
       * | A ✅ | Leaf        | Leaf        | Same parent               | Swap positions (similar to flat tree structure)                             |
       * | B ✅ | Group       | Group       | Same parent               | Swap positions (along with their descendants)                               |
       * | C ✅ | Leaf        | Leaf        | Different parents         | Make source node a child of target's parent and update parent nodes in tree |
       * | D ✅ | Leaf        | Group       | Different parents         | Make source a child of target, only allowed at same depth as source.parent  |
       * | E ❌ | Leaf        | Group       | Target is source's parent | Not allowed, will have no difference                                        |
       * | F ❌ | Group       | Leaf        | Any                       | Not allowed, will break the row grouping criteria                           |
       * | G ✅ | Group       | Group       | Different parents         | Only allowed at same depth to preserve grouping criteria                    |
       */

      if (sourceNode.type === 'group' && targetNode.type === 'leaf') {
        // Case B but not properly detected due to the nature of the drop
        const targetNodeParent = gridRowNodeSelector(apiRef, targetNode.parent);
        if (targetNodeParent.parent === sourceNode.parent) {
          targetNode = targetNodeParent;
        }
      }

      if (
        ((sourceNode.type === 'leaf' && targetNode.type === 'leaf') ||
          (sourceNode.type === 'group' && targetNode.type === 'group')) &&
        sourceNode.parent === targetNode.parent
      ) {
        // Cases A and B
        apiRef.current.setState((state) => {
          const group = gridRowTreeSelector(apiRef)[sourceNode.parent!] as GridGroupNode;
          const currentChildren = group.children;
          const oldIndex = currentChildren.findIndex((row) => row === sourceRowId);
          const targetIndex = currentChildren.findIndex((row) => row === targetNode.id);
          if (oldIndex === -1 || targetIndex === -1 || oldIndex === targetIndex) {
            return state;
          }
          const updatedChildren = [...currentChildren];
          updatedChildren.splice(targetIndex, 0, updatedChildren.splice(oldIndex, 1)[0]);

          return {
            ...state,
            rows: {
              ...state.rows,
              tree: {
                ...state.rows.tree,
                [sourceNode.parent!]: {
                  ...group,
                  children: updatedChildren,
                },
              },
            },
          };
        });
        apiRef.current.publishEvent('rowsSet');
      } else if (
        (sourceNode.type === 'leaf' &&
          targetNode.type === 'leaf' &&
          sourceNode.parent !== targetNode.parent &&
          sourceNode.depth === targetNode.depth) ||
        (sourceNode.type === 'leaf' &&
          targetNode.type === 'group' &&
          targetNode.depth < sourceNode.depth)
      ) {
        // Case C & D
        const source = sourceNode as GridLeafNode;
        let target = targetNode;
        let isLastChild = false;
        if (target.type === 'group') {
          const prevIndex = targetOriginalIndex - 1;
          if (prevIndex < 0) {
            return;
          }
          const prevRowId = sortedFilteredRowIds[prevIndex];
          const leafTargetNode = gridRowNodeSelector(apiRef, prevRowId);
          if (!leafTargetNode || leafTargetNode.type !== 'leaf') {
            return;
          }
          target = leafTargetNode as GridLeafNode;
          isLastChild = true;
        }

        // Extract computation logic
        const sourceGroup = gridRowTreeSelector(apiRef)[source.parent] as GridGroupNode;
        const sourceChildren = sourceGroup.children;

        const targetGroup = gridRowTreeSelector(apiRef)[target.parent] as GridGroupNode;
        const targetChildren = targetGroup.children;

        const sourceIndex = sourceChildren.findIndex((row) => row === sourceRowId);
        const targetIndex = targetChildren.findIndex((row) => row === target.id);
        if (sourceIndex === -1 || targetIndex === -1) {
          return;
        }

        const dataRowIdToModelLookup = gridRowsLookupSelector(apiRef);
        const columnsLookup = gridColumnLookupSelector(apiRef);
        const sanitizedRowGroupingModel = gridRowGroupingSanitizedModelSelector(apiRef);

        // Compute the updated source row
        const originalSourceRow = dataRowIdToModelLookup[sourceRowId];
        let updatedSourceRow = { ...originalSourceRow };
        const targetRow = dataRowIdToModelLookup[target.id];

        // Get grouping rules which include both getter and setter functions
        const groupingRules = getGroupingRules({
          sanitizedRowGroupingModel,
          columnsLookup,
        });

        // Update each grouping field on the source row
        for (const groupingRule of groupingRules) {
          const colDef = columnsLookup[groupingRule.field];

          if (groupingRule.groupingValueSetter && colDef) {
            const targetGroupingValue = getCellGroupingCriteria({
              row: targetRow,
              colDef,
              groupingRule,
              apiRef,
            }).key;

            updatedSourceRow = groupingRule.groupingValueSetter(
              targetGroupingValue,
              updatedSourceRow,
              colDef,
              apiRef,
            );
          } else {
            updatedSourceRow[groupingRule.field] = targetRow[groupingRule.field];
          }
        }

        const commitStateUpdate = (finalSourceRow: GridValidRowModel) => {
          apiRef.current.setState((state) => {
            const updatedSourceChildren = sourceChildren.filter((rowId) => rowId !== sourceRowId);

            let sourceGroupRemoved = false;
            const updatedTree = { ...state.rows.tree };
            if (updatedSourceChildren.length === 0) {
              delete updatedTree[sourceGroup.id];
              sourceGroupRemoved = true;
            }

            const updatedTargetChildren = isLastChild
              ? [...targetChildren, sourceRowId]
              : [
                  ...targetChildren.slice(0, targetIndex),
                  sourceRowId,
                  ...targetChildren.slice(targetIndex),
                ];

            const sourceGroupParent = sourceGroupRemoved
              ? (gridRowTreeSelector(apiRef)[sourceGroup.parent!] as GridGroupNode)
              : null;

            return {
              ...state,
              rows: {
                ...state.rows,
                totalTopLevelRowCount:
                  state.rows.totalTopLevelRowCount - (sourceGroupRemoved ? 1 : 0),
                tree: {
                  ...updatedTree,
                  ...(sourceGroupRemoved && sourceGroupParent
                    ? {
                        [sourceGroupParent.id]: {
                          ...sourceGroupParent,
                          children: sourceGroupParent.children.filter(
                            (childId) => childId !== sourceGroup.id,
                          ),
                        },
                      }
                    : {
                        [source.parent!]: {
                          ...sourceGroup,
                          children: updatedSourceChildren,
                        },
                      }),
                  [target.parent]: {
                    ...targetGroup,
                    children: updatedTargetChildren,
                  },
                  [source.id]: {
                    ...source,
                    parent: target.parent,
                  },
                },
              },
            };
          });

          apiRef.current.updateRows([finalSourceRow]);
          apiRef.current.publishEvent('rowsSet');
        };

        if (processRowUpdate && !isDeepEqual(originalSourceRow, updatedSourceRow)) {
          const params: GridUpdateRowParams = {
            rowId: sourceRowId,
            previousRow: originalSourceRow,
            updatedRow: updatedSourceRow,
          };
          apiRef.current.setLoading(true);

          try {
            Promise.resolve(processRowUpdate(updatedSourceRow, originalSourceRow, params))
              .then((processedRow) => {
                const finalRow = processedRow || updatedSourceRow;
                commitStateUpdate(finalRow);
              })
              .catch((error) => {
                if (onProcessRowUpdateError) {
                  onProcessRowUpdateError(error);
                } else {
                  throw error;
                }
              })
              .finally(() => {
                apiRef.current.setLoading(false);
              });
          } catch (error) {
            apiRef.current.setLoading(false);
            if (onProcessRowUpdateError) {
              onProcessRowUpdateError(error);
            } else {
              throw error;
            }
          }
        } else {
          commitStateUpdate(updatedSourceRow);
        }
      } else if (
        sourceNode.type === 'group' &&
        targetNode.type === 'group' &&
        sourceNode.parent !== targetNode.parent &&
        sourceNode.depth === targetNode.depth
      ) {
        // Case G: Cross-parent group reordering
        const tree = gridRowTreeSelector(apiRef);
        const dataRowIdToModelLookup = gridRowsLookupSelector(apiRef);
        const columnsLookup = gridColumnLookupSelector(apiRef);
        const sanitizedRowGroupingModel = gridRowGroupingSanitizedModelSelector(apiRef);

        // Step 1: Collect all leaf descendants from source group
        const allLeafIds = collectAllLeafDescendants(sourceNode as GridGroupNode, tree);

        if (allLeafIds.length === 0) {
          // No actual rows impacted
          return;
        }

        // Step 2: Initialize batch updater
        const updater = new GroupMoveRowUpdater(processRowUpdate, onProcessRowUpdateError);

        // Step 3: Prepare updated rows with new parent's grouping values
        const groupingRules = getGroupingRules({
          sanitizedRowGroupingModel,
          columnsLookup,
        });

        // We need to determine what grouping values the moved rows should have
        // They should match the target parent's hierarchy
        const targetParentPath = getNodePathInTree({ id: targetNode.parent!, tree });

        for (const leafId of allLeafIds) {
          const originalRow = dataRowIdToModelLookup[leafId];
          let updatedRow = { ...originalRow };

          // Update grouping fields based on the depth level
          // We need to update fields up to the level where the groups differ
          for (let depth = 0; depth < targetParentPath.length; depth += 1) {
            const pathItem = targetParentPath[depth];
            if (pathItem.field) {
              const groupingRule = groupingRules.find((rule) => rule.field === pathItem.field);
              if (groupingRule) {
                const colDef = columnsLookup[groupingRule.field];
                if (groupingRule.groupingValueSetter && colDef) {
                  updatedRow = groupingRule.groupingValueSetter(
                    pathItem.key,
                    updatedRow,
                    colDef,
                    apiRef,
                  );
                } else {
                  updatedRow[groupingRule.field] = pathItem.key;
                }
              }
            }
          }

          updater.queueRowUpdate(leafId, originalRow, updatedRow);
        }

        // Step 4: Set loading state
        apiRef.current.setLoading(true);

        // Step 5: Execute updates and handle partial failures
        updater
          .executeUpdates()
          .then(({ successful, failed, updates }) => {
            // Step 6: Update tree structure based on results
            if (successful.length > 0) {
              apiRef.current.setState((state) => {
                const updatedTree = { ...state.rows.tree };
                const treeDepths = { ...state.rows.treeDepths };

                if (failed.length > 0) {
                  // PARTIAL SUCCESS: Keep source group with failed rows, create/update target group with successful rows

                  // Update source group to only contain failed rows (and their parent groups)
                  const sourceGroupNode = updatedTree[sourceNode.id] as GridGroupNode;
                  const remainingChildren = sourceGroupNode.children.filter((childId) => {
                    const childNode = updatedTree[childId];
                    if (childNode.type === 'leaf') {
                      return failed.includes(childId);
                    }
                    // For nested groups, check if they contain any failed descendants
                    return containsAnyRowIds(childNode as GridGroupNode, failed, updatedTree);
                  });

                  if (remainingChildren.length > 0) {
                    updatedTree[sourceNode.id] = {
                      ...sourceGroupNode,
                      children: remainingChildren,
                    };
                  } else {
                    // Remove empty source group
                    removeNodeFromTree({
                      node: sourceNode,
                      tree: updatedTree,
                      treeDepths,
                    });
                  }

                  // Create or find target group under new parent
                  const targetGroupId = getOrCreateGroupUnderParent(
                    targetNode.parent!,
                    sourceNode.groupingKey as string | number | null,
                    sourceNode.groupingField,
                    updatedTree,
                    treeDepths,
                  );

                  // Move successful rows to target group
                  const targetGroupNode = updatedTree[targetGroupId] as GridGroupNode;
                  const newChildren = [...targetGroupNode.children];

                  successful.forEach((rowId) => {
                    // Update parent reference
                    updatedTree[rowId] = {
                      ...updatedTree[rowId],
                      parent: targetGroupId,
                    };
                    // Add to new parent's children if not already there
                    if (!newChildren.includes(rowId)) {
                      newChildren.push(rowId);
                    }
                  });

                  // Insert at correct position if this is a new group
                  const targetParentChildren = (updatedTree[targetNode.parent!] as GridGroupNode)
                    .children;
                  const targetIndex = targetParentChildren.indexOf(targetNode.id);

                  if (!targetParentChildren.includes(targetGroupId)) {
                    targetParentChildren.splice(targetIndex, 0, targetGroupId);
                  }

                  updatedTree[targetGroupId] = {
                    ...targetGroupNode,
                    children: newChildren,
                  };
                } else {
                  // COMPLETE SUCCESS: Move entire group

                  // Remove from source parent
                  const sourceParentNode = updatedTree[sourceNode.parent!] as GridGroupNode;
                  updatedTree[sourceNode.parent!] = {
                    ...sourceParentNode,
                    children: sourceParentNode.children.filter((id) => id !== sourceNode.id),
                  };

                  // Add to target parent at correct position
                  const tgtParentNode = updatedTree[targetNode.parent!] as GridGroupNode;
                  const targetIndex = tgtParentNode.children.indexOf(targetNode.id);
                  const newTargetChildren = [...tgtParentNode.children];
                  newTargetChildren.splice(targetIndex, 0, sourceNode.id);

                  updatedTree[targetNode.parent!] = {
                    ...tgtParentNode,
                    children: newTargetChildren,
                  };

                  // Update source group's parent reference
                  updatedTree[sourceNode.id] = {
                    ...sourceNode,
                    parent: targetNode.parent,
                  };
                }

                return {
                  ...state,
                  rows: {
                    ...state.rows,
                    tree: updatedTree,
                    treeDepths,
                  },
                };
              });

              // Step 7: Publish event
              apiRef.current.updateRows(updates);
              apiRef.current.publishEvent('rowsSet');
            }
          })
          .finally(() => {
            // Step 8: Clear loading state
            apiRef.current.setLoading(false);
          });
      } else {
        warnOnce(
          [
            'MUI X: The parameters provided to the `setRowIndex()` resulted in a no-op.',
            'Consider looking at the documentation at https://mui.com/x/react-data-grid/row-grouping/',
          ],
          'warning',
        );
      }
    },
    [apiRef, processRowUpdate, onProcessRowUpdateError],
  );

  return {
    setRowIndex,
  };
};
