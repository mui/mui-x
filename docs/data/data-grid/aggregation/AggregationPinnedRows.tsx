import * as React from 'react';
import {
  DataGridPremium,
  GridColDef,
  GRID_AGGREGATION_FUNCTIONS,
  GridAggregationFunction,
  isAutogeneratedRow,
  gridColumnLookupSelector,
  GridRowEntry,
  GridInitialState,
  GRID_ROOT_GROUP_ID,
} from '@mui/x-data-grid-premium';
import { useMovieData } from '@mui/x-data-grid-generator';
import { gridPinnedRowsSelector } from '@mui/x-data-grid/internals';
import { gridPivotActiveSelector } from '@mui/x-data-grid-pro/internals';
import FormControlLabel from '@mui/material/FormControlLabel';
import Checkbox from '@mui/material/Checkbox';

const currencyFormatter = new Intl.NumberFormat('en-US', {
  style: 'currency',
  currency: 'USD',
  minimumFractionDigits: 0,
  maximumFractionDigits: 0,
});

const COLUMNS: GridColDef[] = [
  { field: 'title', headerName: 'Title', width: 200, groupable: false },
  { field: 'year', headerName: 'Year', width: 100, groupable: true },
  {
    field: 'gross',
    headerName: 'Gross',
    type: 'number',
    width: 150,
    groupable: false,
    valueFormatter: (value) => {
      if (!value) {
        return value;
      }
      return currencyFormatter.format(value);
    },
  },
];

const getValuesFromRows = (
  rows: GridRowEntry[],
  aggregationFunction: GridAggregationFunction,
  field: GridColDef['field'],
  isPivotActive: boolean,
  valueGetter: (row: any) => any,
) => {
  const cellValues: any[] = [];
  rows.forEach((rowEntry) => {
    const row = rowEntry.model;
    if (isAutogeneratedRow(row)) {
      // Do not include the pinned aggregation row
      return;
    }
    if (!row) {
      return;
    }

    let value;
    if (typeof aggregationFunction.getCellValue === 'function') {
      value = aggregationFunction.getCellValue({ field, row });
    } else if (isPivotActive) {
      // Since we know that pivoted fields are flat, we can use the row directly, and save lots of processing time
      value = row[field];
    } else {
      value = valueGetter(row);
    }

    if (typeof value !== 'undefined') {
      cellValues.push(value);
    }
  });
  return cellValues;
};

const aggregationFunctionsWithPinnedRows: Record<string, GridAggregationFunction> =
  {};
Object.keys(GRID_AGGREGATION_FUNCTIONS).forEach((name) => {
  const aggFunc =
    GRID_AGGREGATION_FUNCTIONS[name as keyof typeof GRID_AGGREGATION_FUNCTIONS];
  const apply: GridAggregationFunction['apply'] = (params, api) => {
    if (params.groupId !== GRID_ROOT_GROUP_ID) {
      // Pinned rows can only impact top-level aggregation
      return aggFunc.apply(params);
    }
    if (!api) {
      return aggFunc.apply(params);
    }

    const apiRef = { current: api };
    const pinnedRows = gridPinnedRowsSelector(apiRef);
    if (pinnedRows.top.length === 0 && pinnedRows.bottom.length === 0) {
      return aggFunc.apply(params);
    }

    let values = params.values;

    const isPivotActive = gridPivotActiveSelector(apiRef);
    const columnsLookup = gridColumnLookupSelector(apiRef);
    const column = columnsLookup[params.field];
    const valueGetter = (row: any) => apiRef.current.getRowValue(row, column);

    if (pinnedRows.top) {
      const topCellValues = getValuesFromRows(
        pinnedRows.top,
        aggFunc,
        params.field,
        isPivotActive,
        valueGetter,
      );
      if (topCellValues.length > 0) {
        values = topCellValues.concat(values);
      }
    }

    if (pinnedRows.bottom) {
      const bottomCellValues = getValuesFromRows(
        pinnedRows.bottom,
        aggFunc,
        params.field,
        isPivotActive,
        valueGetter,
      );
      if (bottomCellValues.length > 0) {
        values = values.concat(bottomCellValues);
      }
    }

    return aggFunc.apply({ ...params, values });
  };

  aggregationFunctionsWithPinnedRows[name] = {
    ...aggFunc,
    apply,
  };
});

export default function AggregationPinnedRows() {
  const data = useMovieData();
  const [includePinnedRows, setIncludePinnedRows] = React.useState(true);

  const initialState = React.useMemo<GridInitialState>(() => {
    return {
      aggregation: {
        model: {
          gross: 'sum',
        },
      },
    };
  }, []);

  const { rows, topRows, bottomRows } = React.useMemo(() => {
    const nonPinnedRows = [...data.rows];
    return {
      topRows: [nonPinnedRows.shift()],
      rows: nonPinnedRows,
      bottomRows: [nonPinnedRows.pop()],
    };
  }, [data.rows]);

  return (
    <div style={{ width: '100%' }}>
      <FormControlLabel
        sx={{ ml: 0 }}
        control={
          <Checkbox
            checked={includePinnedRows}
            onChange={(ev) => setIncludePinnedRows(ev.target.checked)}
          />
        }
        label="Aggregate pinned rows"
      />
      <div style={{ height: 400 }}>
        <DataGridPremium
          rows={rows}
          columns={COLUMNS}
          initialState={initialState}
          pinnedRows={{
            top: topRows,
            bottom: bottomRows,
          }}
          aggregationFunctions={
            includePinnedRows
              ? aggregationFunctionsWithPinnedRows
              : GRID_AGGREGATION_FUNCTIONS
          }
        />
      </div>
    </div>
  );
}
