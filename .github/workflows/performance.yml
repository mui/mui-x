name: Performance

on:
  pull_request:
    types:
      - opened
      - synchronize
      - reopened
  pull_request_target:
    types:
      - opened
      - synchronize
      - reopened

permissions:
  pull-requests: write

jobs:
  performance:
    name: Performance Comparison
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4.2.0
        with:
          version: 10.27.0
          run_install: false

      - name: Use Node.js 22.x
        uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # v6.2.0
        with:
          node-version: 22.18.0
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build packages
        run: pnpm --filter @mui/x-charts-premium... build

      - name: Install Playwright browsers
        run: pnpm --filter benchmark-tool exec playwright install chromium --with-deps

      - name: Run benchmarks
        run: pnpm --filter benchmark-tool test

      - name: Extract metrics and compare
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Extract metrics from PR benchmark results
            function extractMetrics(trace) {
              const durationByEvent = {};
              let totalDuration = 0;
              let eventCount = 0;

              for (const event of trace.traceEvents) {
                if (event.ph === 'X') {
                  totalDuration += event.dur;
                  eventCount += 1;
                  // Include phase (mount/update) in the event key for better granularity
                  const phase = event.args?.phase;
                  const eventKey = phase ? `${event.name} (${phase})` : event.name;
                  durationByEvent[eventKey] = (durationByEvent[eventKey] ?? 0) + event.dur;
                }
              }

              return { totalDuration, eventCount, durationByEvent };
            }

            // Read PR benchmark results
            const benchmarksDir = './test/benchmark-tool/benchmarks';
            let prMetrics = { totalDuration: 0, eventCount: 0, durationByEvent: {} };

            if (fs.existsSync(benchmarksDir)) {
              const files = fs.readdirSync(benchmarksDir).filter(f => f.endsWith('.json'));
              for (const file of files) {
                const trace = JSON.parse(fs.readFileSync(path.join(benchmarksDir, file), 'utf-8'));
                const metrics = extractMetrics(trace);
                prMetrics.totalDuration += metrics.totalDuration;
                prMetrics.eventCount += metrics.eventCount;
                for (const [event, duration] of Object.entries(metrics.durationByEvent)) {
                  prMetrics.durationByEvent[event] = (prMetrics.durationByEvent[event] ?? 0) + duration;
                }
              }
            }

            // Fetch baseline metrics from performance-benchmark-data repository
            // Find the latest benchmark folder (YYYY-MM-DD-HH-MM-SS format)
            let masterMetrics = null;
            try {
              // List directories in mui-x folder using GitHub API
              const contentsResponse = await fetch('https://api.github.com/repos/mnajdova/performance-benchmark-data/contents/mui-x');
              if (contentsResponse.ok) {
                const contents = await contentsResponse.json();
                // Filter directories and sort by name (timestamp format sorts chronologically)
                const folders = contents
                  .filter(item => item.type === 'dir')
                  .map(item => item.name)
                  .sort()
                  .reverse();

                if (folders.length > 0) {
                  const latestFolder = folders[0];
                  console.log(`Using latest benchmark folder: ${latestFolder}`);

                  // Fetch metadata.json to get the list of benchmark files
                  const metadataResponse = await fetch(`https://raw.githubusercontent.com/mnajdova/performance-benchmark-data/main/mui-x/${latestFolder}/metadata.json`);
                  if (metadataResponse.ok) {
                    const metadata = await metadataResponse.json();
                    masterMetrics = { totalDuration: 0, eventCount: 0, durationByEvent: {} };

                    // Fetch and aggregate metrics from each benchmark file listed in metadata
                    for (const filePath of metadata.files) {
                      const fileName = filePath.split('/').pop();
                      const fileResponse = await fetch(`https://raw.githubusercontent.com/mnajdova/performance-benchmark-data/main/mui-x/${latestFolder}/${fileName}`);
                      if (fileResponse.ok) {
                        const trace = await fileResponse.json();
                        const metrics = extractMetrics(trace);
                        masterMetrics.totalDuration += metrics.totalDuration;
                        masterMetrics.eventCount += metrics.eventCount;
                        for (const [event, duration] of Object.entries(metrics.durationByEvent)) {
                          masterMetrics.durationByEvent[event] = (masterMetrics.durationByEvent[event] ?? 0) + duration;
                        }
                      }
                    }
                  }
                }
              }
            } catch (e) {
              console.log('Could not fetch baseline metrics:', e.message);
            }

            const prDuration = prMetrics.totalDuration;

            let body;
            if (masterMetrics) {
              const masterDuration = masterMetrics.totalDuration;
              const diff = prDuration - masterDuration;
              const diffPercent = masterDuration > 0 ? ((diff / masterDuration) * 100).toFixed(2) : 'N/A';
              const emoji = diff > 0 ? 'ðŸ”º' : diff < 0 ? 'ðŸ”½' : 'âž¡ï¸';

              body = `## Performance Comparison

            | Metric | Master | PR | Diff |
            |--------|--------|-----|------|
            | Total Duration (Î¼s) | ${masterDuration.toLocaleString()} | ${prDuration.toLocaleString()} | ${emoji} ${diff > 0 ? '+' : ''}${diff.toLocaleString()} (${diffPercent}%) |
            | Event Count | ${masterMetrics.eventCount} | ${prMetrics.eventCount} | ${prMetrics.eventCount - masterMetrics.eventCount} |

            <details>
            <summary>Duration by Event Type</summary>

            | Event | Master (Î¼s) | PR (Î¼s) |
            |-------|-------------|---------|
            ${Object.keys({ ...masterMetrics.durationByEvent, ...prMetrics.durationByEvent })
              .map(event => `| ${event} | ${(masterMetrics.durationByEvent[event] || 0).toLocaleString()} | ${(prMetrics.durationByEvent[event] || 0).toLocaleString()} |`)
              .join('\n')}

            </details>
            `;
            } else {
              body = `## Performance Comparison

            > **Note:** Baseline metrics not found. Showing PR metrics only.

            | Metric | PR |
            |--------|-----|
            | Total Duration (Î¼s) | ${prDuration.toLocaleString()} |
            | Event Count | ${prMetrics.eventCount} |

            <details>
            <summary>Duration by Event Type</summary>

            | Event | PR (Î¼s) |
            |-------|---------|
            ${Object.keys(prMetrics.durationByEvent)
              .map(event => `| ${event} | ${prMetrics.durationByEvent[event].toLocaleString()} |`)
              .join('\n')}

            </details>
            `;
            }

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' && comment.body.includes('## Performance Comparison')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body,
              });
            }
